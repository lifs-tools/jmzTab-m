/*
 * mzTab-M reference implementation and validation API.
 * This is the mzTab-M reference implementation and validation API service.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: nils.hoffmann@cebitec.uni-bielefeld.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.lifstools.mztab2.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import java.util.Locale;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.net.URI;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.lifstools.mztab2.model.Instrument;
import org.lifstools.mztab2.model.Parameter;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import jakarta.validation.constraints.*;
import jakarta.validation.Valid;
import org.hibernate.validator.constraints.*;

/**
 * Specification of ms_run.  location: Location of the external data file e.g. raw files on which analysis has been performed. If the actual location of the MS run is unknown, a “null” MUST be used as a place holder value, since the [1-n] cardinality is referenced elsewhere. If pre-fractionation has been performed, then [1-n] ms_runs SHOULD be created per assay.  instrument_ref: If different instruments are used in different runs, instrument_ref can be used to link a specific instrument to a specific run.  format: Parameter specifying the data format of the external MS data file. If ms_run[1-n]-format is present, ms_run[1-n]-id_format SHOULD also be present, following the parameters specified in Table 1.  id_format: Parameter specifying the id format used in the external data file. If ms_run[1-n]-id_format is present, ms_run[1-n]-format SHOULD also be present. fragmentation_method: The type(s) of fragmentation used in a given ms run. scan_polarity: The polarity mode of a given run. Usually only one value SHOULD be given here except for the case of mixed polarity runs. hash: Hash value of the corresponding external MS data file defined in ms_run[1-n]-location. If ms_run[1-n]-hash is present, ms_run[1-n]-hash_method SHOULD also be present. hash_method: A parameter specifying the hash methods used to generate the String in ms_run[1-n]-hash. Specifics of the hash method used MAY follow the definitions of the mzML format. If ms_run[1-n]-hash is present, ms_run[1-n]-hash_method SHOULD also be present. 
 */
@JsonPropertyOrder({
  MsRun.JSON_PROPERTY_ID,
  MsRun.JSON_PROPERTY_NAME,
  MsRun.JSON_PROPERTY_LOCATION,
  MsRun.JSON_PROPERTY_INSTRUMENT_REF,
  MsRun.JSON_PROPERTY_FORMAT,
  MsRun.JSON_PROPERTY_ID_FORMAT,
  MsRun.JSON_PROPERTY_FRAGMENTATION_METHOD,
  MsRun.JSON_PROPERTY_SCAN_POLARITY,
  MsRun.JSON_PROPERTY_HASH,
  MsRun.JSON_PROPERTY_HASH_METHOD
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-11-08T17:12:00.460651+01:00[Europe/Berlin]", comments = "Generator version: 7.17.0")
public class MsRun {

  /**
   * Property enumeration for MsRun.
   */
  public static enum Properties {
      id("id"), 
      name("name"), 
      location("location"), 
      instrumentRef("instrument_ref"), 
      format("format"), 
      idFormat("id_format"), 
      fragmentationMethod("fragmentation_method"), 
      scanPolarity("scan_polarity"), 
      hash("hash"), 
      hashMethod("hash_method");

    private final String propertyName;

    private Properties(String propertyName) {
      this.propertyName = propertyName;
    }

    public String getPropertyName() {
      return propertyName;
    }

    public String toString() {
      return propertyName;
    }

    public String toUpper() {
      return propertyName.toUpperCase();
    }

    public static Properties of(String value) {
      if(value==null) {
        throw new NullPointerException("Argument value must not be null!");
      }
      return Arrays.asList(Properties.values()).stream().filter(m -> m.propertyName.equals(value.toLowerCase())).findAny().orElseThrow(IllegalArgumentException::new);
    }
  };
  
  public static final String JSON_PROPERTY_ID = "id";
  @jakarta.validation.constraints.NotNull
  private Integer id;

  public static final String JSON_PROPERTY_NAME = "name";
  
  private String name;

  public static final String JSON_PROPERTY_LOCATION = "location";
  @jakarta.validation.constraints.NotNull
  private URI location;

  public static final String JSON_PROPERTY_INSTRUMENT_REF = "instrument_ref";
  
  private Instrument instrumentRef;

  public static final String JSON_PROPERTY_FORMAT = "format";
  
  private Parameter format;

  public static final String JSON_PROPERTY_ID_FORMAT = "id_format";
  
  private Parameter idFormat;

  public static final String JSON_PROPERTY_FRAGMENTATION_METHOD = "fragmentation_method";
  
  private List<@Valid Parameter> fragmentationMethod = new ArrayList<>();

  public static final String JSON_PROPERTY_SCAN_POLARITY = "scan_polarity";
  
  private List<@Valid Parameter> scanPolarity = new ArrayList<>();

  public static final String JSON_PROPERTY_HASH = "hash";
  
  private String hash;

  public static final String JSON_PROPERTY_HASH_METHOD = "hash_method";
  
  private Parameter hashMethod;

  public MsRun() { 
  }

  public MsRun id(@jakarta.validation.constraints.NotNull Integer id) {
    this.id = id;
    return this;
  }

  /**
   * Get id
   * minimum: 1
   * @return id
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Min(1)
  @JsonProperty(value = JSON_PROPERTY_ID, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Integer getId() {
    return id;
  }


  @JsonProperty(value = JSON_PROPERTY_ID, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setId(@jakarta.validation.constraints.NotNull Integer id) {
    this.id = id;
  }


  public MsRun name( String name) {
    this.name = name;
    return this;
  }

  /**
   * The msRun&#39;s name.
   * @return name
   */
  

  @JsonProperty(value = JSON_PROPERTY_NAME, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getName() {
    return name;
  }


  @JsonProperty(value = JSON_PROPERTY_NAME, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setName( String name) {
    this.name = name;
  }


  public MsRun location(@jakarta.validation.constraints.NotNull URI location) {
    this.location = location;
    return this;
  }

  /**
   * The msRun&#39;s location URI.
   * @return location
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_LOCATION, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public URI getLocation() {
    return location;
  }


  @JsonProperty(value = JSON_PROPERTY_LOCATION, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setLocation(@jakarta.validation.constraints.NotNull URI location) {
    this.location = location;
  }


  public MsRun instrumentRef( Instrument instrumentRef) {
    this.instrumentRef = instrumentRef;
    return this;
  }

  /**
   * Get instrumentRef
   * @return instrumentRef
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_INSTRUMENT_REF, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Instrument getInstrumentRef() {
    return instrumentRef;
  }


  @JsonProperty(value = JSON_PROPERTY_INSTRUMENT_REF, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setInstrumentRef( Instrument instrumentRef) {
    this.instrumentRef = instrumentRef;
  }


  public MsRun format( Parameter format) {
    this.format = format;
    return this;
  }

  /**
   * Get format
   * @return format
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_FORMAT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Parameter getFormat() {
    return format;
  }


  @JsonProperty(value = JSON_PROPERTY_FORMAT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFormat( Parameter format) {
    this.format = format;
  }


  public MsRun idFormat( Parameter idFormat) {
    this.idFormat = idFormat;
    return this;
  }

  /**
   * Get idFormat
   * @return idFormat
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_ID_FORMAT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Parameter getIdFormat() {
    return idFormat;
  }


  @JsonProperty(value = JSON_PROPERTY_ID_FORMAT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIdFormat( Parameter idFormat) {
    this.idFormat = idFormat;
  }


  public MsRun fragmentationMethod( List<@Valid Parameter> fragmentationMethod) {
    this.fragmentationMethod = fragmentationMethod;
    return this;
  }

  public MsRun addFragmentationMethodItem(Parameter fragmentationMethodItem) {
    if (this.fragmentationMethod == null) {
      this.fragmentationMethod = new ArrayList<>();
    }
    this.fragmentationMethod.add(fragmentationMethodItem);
    return this;
  }

  /**
   * The fragmentation methods applied during this msRun.
   * @return fragmentationMethod
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_FRAGMENTATION_METHOD, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid Parameter> getFragmentationMethod() {
    return fragmentationMethod;
  }


  @JsonProperty(value = JSON_PROPERTY_FRAGMENTATION_METHOD, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setFragmentationMethod( List<@Valid Parameter> fragmentationMethod) {
    this.fragmentationMethod = fragmentationMethod;
  }


  public MsRun scanPolarity( List<@Valid Parameter> scanPolarity) {
    this.scanPolarity = scanPolarity;
    return this;
  }

  public MsRun addScanPolarityItem(Parameter scanPolarityItem) {
    if (this.scanPolarity == null) {
      this.scanPolarity = new ArrayList<>();
    }
    this.scanPolarity.add(scanPolarityItem);
    return this;
  }

  /**
   * The scan polarity/polarities used during this msRun.
   * @return scanPolarity
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_SCAN_POLARITY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid Parameter> getScanPolarity() {
    return scanPolarity;
  }


  @JsonProperty(value = JSON_PROPERTY_SCAN_POLARITY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setScanPolarity( List<@Valid Parameter> scanPolarity) {
    this.scanPolarity = scanPolarity;
  }


  public MsRun hash( String hash) {
    this.hash = hash;
    return this;
  }

  /**
   * The file hash value of this msRun&#39;s data file.
   * @return hash
   */
  

  @JsonProperty(value = JSON_PROPERTY_HASH, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getHash() {
    return hash;
  }


  @JsonProperty(value = JSON_PROPERTY_HASH, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setHash( String hash) {
    this.hash = hash;
  }


  public MsRun hashMethod( Parameter hashMethod) {
    this.hashMethod = hashMethod;
    return this;
  }

  /**
   * Get hashMethod
   * @return hashMethod
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_HASH_METHOD, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Parameter getHashMethod() {
    return hashMethod;
  }


  @JsonProperty(value = JSON_PROPERTY_HASH_METHOD, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setHashMethod( Parameter hashMethod) {
    this.hashMethod = hashMethod;
  }


  /**
   * Return true if this MsRun object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MsRun msRun = (MsRun) o;
    return Objects.equals(this.id, msRun.id) &&
        Objects.equals(this.name, msRun.name) &&
        Objects.equals(this.location, msRun.location) &&
        Objects.equals(this.instrumentRef, msRun.instrumentRef) &&
        Objects.equals(this.format, msRun.format) &&
        Objects.equals(this.idFormat, msRun.idFormat) &&
        Objects.equals(this.fragmentationMethod, msRun.fragmentationMethod) &&
        Objects.equals(this.scanPolarity, msRun.scanPolarity) &&
        Objects.equals(this.hash, msRun.hash) &&
        Objects.equals(this.hashMethod, msRun.hashMethod);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, name, location, instrumentRef, format, idFormat, fragmentationMethod, scanPolarity, hash, hashMethod);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MsRun {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    name: ").append(toIndentedString(name)).append("\n");
    sb.append("    location: ").append(toIndentedString(location)).append("\n");
    sb.append("    instrumentRef: ").append(toIndentedString(instrumentRef)).append("\n");
    sb.append("    format: ").append(toIndentedString(format)).append("\n");
    sb.append("    idFormat: ").append(toIndentedString(idFormat)).append("\n");
    sb.append("    fragmentationMethod: ").append(toIndentedString(fragmentationMethod)).append("\n");
    sb.append("    scanPolarity: ").append(toIndentedString(scanPolarity)).append("\n");
    sb.append("    hash: ").append(toIndentedString(hash)).append("\n");
    sb.append("    hashMethod: ").append(toIndentedString(hashMethod)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

