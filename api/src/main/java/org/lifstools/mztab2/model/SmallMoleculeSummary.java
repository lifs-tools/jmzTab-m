/*
 * mzTab-M reference implementation and validation API.
 * This is the mzTab-M reference implementation and validation API service.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: nils.hoffmann@cebitec.uni-bielefeld.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.lifstools.mztab2.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import java.util.Locale;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.net.URI;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.lifstools.mztab2.model.Comment;
import org.lifstools.mztab2.model.OptColumnMapping;
import org.lifstools.mztab2.model.Parameter;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import jakarta.validation.constraints.*;
import jakarta.validation.Valid;
import org.hibernate.validator.constraints.*;

/**
 * The small molecule summary section is table-based, represented summarized quantitative information across assays and study variables, grouped by identification in rows. The small molecule section MUST always come after the metadata section. All table columns MUST be Tab separated. There MUST NOT be any empty cells; missing values MUST be reported using “null” for columns where Is Nullable &#x3D; “True”.  Each row of the small molecule section is intended to report one final result to be communicated in terms of a molecule that has been quantified. In many cases, this may be the molecule of biological interest, although in some cases, the final result could be a derivatized form as appropriate – although it is desirable for the database identifier(s) to reference to the biological (non-derivatized) form. In general, different adduct forms would generally be reported in the Small Molecule Feature section.  The order of columns MUST follow the order specified below.  All columns are MANDATORY except for “opt_” columns. 
 */
@JsonPropertyOrder({
  SmallMoleculeSummary.JSON_PROPERTY_PREFIX,
  SmallMoleculeSummary.JSON_PROPERTY_HEADER_PREFIX,
  SmallMoleculeSummary.JSON_PROPERTY_SML_ID,
  SmallMoleculeSummary.JSON_PROPERTY_SMF_ID_REFS,
  SmallMoleculeSummary.JSON_PROPERTY_DATABASE_IDENTIFIER,
  SmallMoleculeSummary.JSON_PROPERTY_CHEMICAL_FORMULA,
  SmallMoleculeSummary.JSON_PROPERTY_SMILES,
  SmallMoleculeSummary.JSON_PROPERTY_INCHI,
  SmallMoleculeSummary.JSON_PROPERTY_CHEMICAL_NAME,
  SmallMoleculeSummary.JSON_PROPERTY_URI,
  SmallMoleculeSummary.JSON_PROPERTY_THEORETICAL_NEUTRAL_MASS,
  SmallMoleculeSummary.JSON_PROPERTY_ADDUCT_IONS,
  SmallMoleculeSummary.JSON_PROPERTY_RELIABILITY,
  SmallMoleculeSummary.JSON_PROPERTY_BEST_ID_CONFIDENCE_MEASURE,
  SmallMoleculeSummary.JSON_PROPERTY_BEST_ID_CONFIDENCE_VALUE,
  SmallMoleculeSummary.JSON_PROPERTY_ABUNDANCE_ASSAY,
  SmallMoleculeSummary.JSON_PROPERTY_ABUNDANCE_STUDY_VARIABLE,
  SmallMoleculeSummary.JSON_PROPERTY_ABUNDANCE_VARIATION_STUDY_VARIABLE,
  SmallMoleculeSummary.JSON_PROPERTY_OPT,
  SmallMoleculeSummary.JSON_PROPERTY_COMMENT
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-11-08T17:12:00.460651+01:00[Europe/Berlin]", comments = "Generator version: 7.17.0")
public class SmallMoleculeSummary {

  /**
   * Property enumeration for SmallMoleculeSummary.
   */
  public static enum Properties {
      prefix("prefix"), 
      headerPrefix("header_prefix"), 
      smlId("sml_id"), 
      smfIdRefs("smf_id_refs"), 
      databaseIdentifier("database_identifier"), 
      chemicalFormula("chemical_formula"), 
      smiles("smiles"), 
      inchi("inchi"), 
      chemicalName("chemical_name"), 
      uri("uri"), 
      theoreticalNeutralMass("theoretical_neutral_mass"), 
      adductIons("adduct_ions"), 
      reliability("reliability"), 
      bestIdConfidenceMeasure("best_id_confidence_measure"), 
      bestIdConfidenceValue("best_id_confidence_value"), 
      abundanceAssay("abundance_assay"), 
      abundanceStudyVariable("abundance_study_variable"), 
      abundanceVariationStudyVariable("abundance_variation_study_variable"), 
      opt("opt"), 
      comment("comment");

    private final String propertyName;

    private Properties(String propertyName) {
      this.propertyName = propertyName;
    }

    public String getPropertyName() {
      return propertyName;
    }

    public String toString() {
      return propertyName;
    }

    public String toUpper() {
      return propertyName.toUpperCase();
    }

    public static Properties of(String value) {
      if(value==null) {
        throw new NullPointerException("Argument value must not be null!");
      }
      return Arrays.asList(Properties.values()).stream().filter(m -> m.propertyName.equals(value.toLowerCase())).findAny().orElseThrow(IllegalArgumentException::new);
    }
  };
  
  /**
   * The small molecule table row prefix. SML MUST be used for rows of the small molecule table.
   */
  public enum PrefixEnum {
    SML(String.valueOf("SML"));

    private String value;

    PrefixEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static PrefixEnum fromValue(String value) {
      for (PrefixEnum b : PrefixEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_PREFIX = "prefix";
  
  private PrefixEnum prefix = PrefixEnum.SML;

  /**
   * The small molecule table header prefix. SMH MUST be used for the small molecule table header line (the column labels).
   */
  public enum HeaderPrefixEnum {
    SMH(String.valueOf("SMH"));

    private String value;

    HeaderPrefixEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static HeaderPrefixEnum fromValue(String value) {
      for (HeaderPrefixEnum b : HeaderPrefixEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_HEADER_PREFIX = "header_prefix";
  
  private HeaderPrefixEnum headerPrefix = HeaderPrefixEnum.SMH;

  public static final String JSON_PROPERTY_SML_ID = "sml_id";
  @jakarta.validation.constraints.NotNull
  private Integer smlId;

  public static final String JSON_PROPERTY_SMF_ID_REFS = "smf_id_refs";
  
  private List<Integer> smfIdRefs = new ArrayList<>();

  public static final String JSON_PROPERTY_DATABASE_IDENTIFIER = "database_identifier";
  
  private List<String> databaseIdentifier = new ArrayList<>();

  public static final String JSON_PROPERTY_CHEMICAL_FORMULA = "chemical_formula";
  
  private List<String> chemicalFormula = new ArrayList<>();

  public static final String JSON_PROPERTY_SMILES = "smiles";
  
  private List<String> smiles = new ArrayList<>();

  public static final String JSON_PROPERTY_INCHI = "inchi";
  
  private List<String> inchi = new ArrayList<>();

  public static final String JSON_PROPERTY_CHEMICAL_NAME = "chemical_name";
  
  private List<String> chemicalName = new ArrayList<>();

  public static final String JSON_PROPERTY_URI = "uri";
  
  private List<URI> uri = new ArrayList<>();

  public static final String JSON_PROPERTY_THEORETICAL_NEUTRAL_MASS = "theoretical_neutral_mass";
  
  private List<Double> theoreticalNeutralMass = new ArrayList<>();

  public static final String JSON_PROPERTY_ADDUCT_IONS = "adduct_ions";
  
  private List<String> adductIons = new ArrayList<>();

  public static final String JSON_PROPERTY_RELIABILITY = "reliability";
  
  private String reliability;

  public static final String JSON_PROPERTY_BEST_ID_CONFIDENCE_MEASURE = "best_id_confidence_measure";
  
  private Parameter bestIdConfidenceMeasure;

  public static final String JSON_PROPERTY_BEST_ID_CONFIDENCE_VALUE = "best_id_confidence_value";
  
  private Double bestIdConfidenceValue;

  public static final String JSON_PROPERTY_ABUNDANCE_ASSAY = "abundance_assay";
  
  private List<Double> abundanceAssay = new ArrayList<>();

  public static final String JSON_PROPERTY_ABUNDANCE_STUDY_VARIABLE = "abundance_study_variable";
  
  private List<Double> abundanceStudyVariable = new ArrayList<>();

  public static final String JSON_PROPERTY_ABUNDANCE_VARIATION_STUDY_VARIABLE = "abundance_variation_study_variable";
  
  private List<Double> abundanceVariationStudyVariable = new ArrayList<>();

  public static final String JSON_PROPERTY_OPT = "opt";
  
  private List<@Valid OptColumnMapping> opt = new ArrayList<>();

  public static final String JSON_PROPERTY_COMMENT = "comment";
  
  private List<@Valid Comment> comment = new ArrayList<>();

  public SmallMoleculeSummary() { 
  }

  @JsonCreator
  public SmallMoleculeSummary(
    @JsonProperty(JSON_PROPERTY_PREFIX) PrefixEnum prefix, 
    @JsonProperty(JSON_PROPERTY_HEADER_PREFIX) HeaderPrefixEnum headerPrefix
  ) {
  this();
    this.prefix = prefix;
    this.headerPrefix = headerPrefix;
  }

  /**
   * The small molecule table row prefix. SML MUST be used for rows of the small molecule table.
   * @return prefix
   */
  

  @JsonProperty(value = JSON_PROPERTY_PREFIX, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public PrefixEnum getPrefix() {
    return prefix;
  }




  /**
   * The small molecule table header prefix. SMH MUST be used for the small molecule table header line (the column labels).
   * @return headerPrefix
   */
  

  @JsonProperty(value = JSON_PROPERTY_HEADER_PREFIX, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public HeaderPrefixEnum getHeaderPrefix() {
    return headerPrefix;
  }




  public SmallMoleculeSummary smlId(@jakarta.validation.constraints.NotNull Integer smlId) {
    this.smlId = smlId;
    return this;
  }

  /**
   * A within file unique identifier for the small molecule.
   * @return smlId
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @JsonProperty(value = JSON_PROPERTY_SML_ID, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Integer getSmlId() {
    return smlId;
  }


  @JsonProperty(value = JSON_PROPERTY_SML_ID, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSmlId(@jakarta.validation.constraints.NotNull Integer smlId) {
    this.smlId = smlId;
  }


  public SmallMoleculeSummary smfIdRefs( List<Integer> smfIdRefs) {
    this.smfIdRefs = smfIdRefs;
    return this;
  }

  public SmallMoleculeSummary addSmfIdRefsItem(Integer smfIdRefsItem) {
    if (this.smfIdRefs == null) {
      this.smfIdRefs = new ArrayList<>();
    }
    this.smfIdRefs.add(smfIdRefsItem);
    return this;
  }

  /**
   * References to all the features on which quantitation has been based (SMF elements) via referencing SMF_ID values. Multiple values SHOULD be provided as a “|” separated list. This MAY be null only if this is a Summary file.
   * @return smfIdRefs
   */
  

  @JsonProperty(value = JSON_PROPERTY_SMF_ID_REFS, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<Integer> getSmfIdRefs() {
    return smfIdRefs;
  }


  @JsonProperty(value = JSON_PROPERTY_SMF_ID_REFS, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSmfIdRefs( List<Integer> smfIdRefs) {
    this.smfIdRefs = smfIdRefs;
  }


  public SmallMoleculeSummary databaseIdentifier( List<String> databaseIdentifier) {
    this.databaseIdentifier = databaseIdentifier;
    return this;
  }

  public SmallMoleculeSummary addDatabaseIdentifierItem(String databaseIdentifierItem) {
    if (this.databaseIdentifier == null) {
      this.databaseIdentifier = new ArrayList<>();
    }
    this.databaseIdentifier.add(databaseIdentifierItem);
    return this;
  }

  /**
   * A list of “|” separated possible identifiers for the small molecule; multiple values MUST only be provided to indicate ambiguity in the identification of the molecule and not to demonstrate different identifier types for the same molecule. Alternative identifiers for the same molecule MAY be provided as optional columns.  The database identifier must be preceded by the resource description (prefix) followed by a colon, as specified in the metadata section.      A null value MAY be provided if the identification is sufficiently ambiguous as to be meaningless for reporting or the small molecule has not been identified. 
   * @return databaseIdentifier
   */
  

  @JsonProperty(value = JSON_PROPERTY_DATABASE_IDENTIFIER, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<String> getDatabaseIdentifier() {
    return databaseIdentifier;
  }


  @JsonProperty(value = JSON_PROPERTY_DATABASE_IDENTIFIER, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDatabaseIdentifier( List<String> databaseIdentifier) {
    this.databaseIdentifier = databaseIdentifier;
  }


  public SmallMoleculeSummary chemicalFormula( List<String> chemicalFormula) {
    this.chemicalFormula = chemicalFormula;
    return this;
  }

  public SmallMoleculeSummary addChemicalFormulaItem(String chemicalFormulaItem) {
    if (this.chemicalFormula == null) {
      this.chemicalFormula = new ArrayList<>();
    }
    this.chemicalFormula.add(chemicalFormulaItem);
    return this;
  }

  /**
   * A list of “|” separated potential chemical formulae of the reported compound. The number of values provided MUST match the number of entities reported under “database_identifier”, even if this leads to redundant reporting of information (i.e. if ambiguity can be resolved in the chemical formula), and the validation software will throw an error if the number of “|” symbols does not match. “null” values between bars are allowed.  This should be specified in Hill notation (EA Hill 1900), i.e. elements in the order C, H and then alphabetically all other elements. Counts of one may be omitted. Elements should be capitalized properly to avoid confusion (e.g., “CO” vs. “Co”). The chemical formula reported should refer to the neutral form.  Example: N-acetylglucosamine would be encoded by the string “C8H15NO6”. 
   * @return chemicalFormula
   */
  

  @JsonProperty(value = JSON_PROPERTY_CHEMICAL_FORMULA, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<String> getChemicalFormula() {
    return chemicalFormula;
  }


  @JsonProperty(value = JSON_PROPERTY_CHEMICAL_FORMULA, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setChemicalFormula( List<String> chemicalFormula) {
    this.chemicalFormula = chemicalFormula;
  }


  public SmallMoleculeSummary smiles( List<String> smiles) {
    this.smiles = smiles;
    return this;
  }

  public SmallMoleculeSummary addSmilesItem(String smilesItem) {
    if (this.smiles == null) {
      this.smiles = new ArrayList<>();
    }
    this.smiles.add(smilesItem);
    return this;
  }

  /**
   * A list of “|” separated potential molecule structures in the simplified molecular-input line-entry system (SMILES) for the small molecule. The number of values provided MUST match the number of entities reported under “database_identifier”, and the validation software will throw an error if the number of “|” symbols does not match. “null” values between bars are allowed.
   * @return smiles
   */
  

  @JsonProperty(value = JSON_PROPERTY_SMILES, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<String> getSmiles() {
    return smiles;
  }


  @JsonProperty(value = JSON_PROPERTY_SMILES, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSmiles( List<String> smiles) {
    this.smiles = smiles;
  }


  public SmallMoleculeSummary inchi( List<String> inchi) {
    this.inchi = inchi;
    return this;
  }

  public SmallMoleculeSummary addInchiItem(String inchiItem) {
    if (this.inchi == null) {
      this.inchi = new ArrayList<>();
    }
    this.inchi.add(inchiItem);
    return this;
  }

  /**
   * A list of “|” separated potential standard IUPAC International Chemical Identifier (InChI) of the given substance.  The number of values provided MUST match the number of entities reported under “database_identifier”, even if this leads to redundant information being reported (i.e. if ambiguity can be resolved in the InChi), and the validation software will throw an error if the number of “|” symbols does not match. “null” values between bars are allowed. 
   * @return inchi
   */
  

  @JsonProperty(value = JSON_PROPERTY_INCHI, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<String> getInchi() {
    return inchi;
  }


  @JsonProperty(value = JSON_PROPERTY_INCHI, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setInchi( List<String> inchi) {
    this.inchi = inchi;
  }


  public SmallMoleculeSummary chemicalName( List<String> chemicalName) {
    this.chemicalName = chemicalName;
    return this;
  }

  public SmallMoleculeSummary addChemicalNameItem(String chemicalNameItem) {
    if (this.chemicalName == null) {
      this.chemicalName = new ArrayList<>();
    }
    this.chemicalName.add(chemicalNameItem);
    return this;
  }

  /**
   * A list of “|” separated possible chemical/common names for the small molecule, or general description if a chemical name is unavailable. Multiple names are only to demonstrate ambiguity in the identification. The number of values provided MUST match the number of entities reported under “database_identifier”, and the validation software will throw an error if the number of “|” symbols does not match. “null” values between bars are allowed. 
   * @return chemicalName
   */
  

  @JsonProperty(value = JSON_PROPERTY_CHEMICAL_NAME, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<String> getChemicalName() {
    return chemicalName;
  }


  @JsonProperty(value = JSON_PROPERTY_CHEMICAL_NAME, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setChemicalName( List<String> chemicalName) {
    this.chemicalName = chemicalName;
  }


  public SmallMoleculeSummary uri( List<URI> uri) {
    this.uri = uri;
    return this;
  }

  public SmallMoleculeSummary addUriItem(URI uriItem) {
    if (this.uri == null) {
      this.uri = new ArrayList<>();
    }
    this.uri.add(uriItem);
    return this;
  }

  /**
   * A URI pointing to the small molecule’s entry in a reference database (e.g., the small molecule’s HMDB or KEGG entry). The number of values provided MUST match the number of entities reported under “database_identifier”, and the validation software will throw an error if the number of “|” symbols does not match. “null” values between bars are allowed.
   * @return uri
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_URI, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<URI> getUri() {
    return uri;
  }


  @JsonProperty(value = JSON_PROPERTY_URI, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUri( List<URI> uri) {
    this.uri = uri;
  }


  public SmallMoleculeSummary theoreticalNeutralMass( List<Double> theoreticalNeutralMass) {
    this.theoreticalNeutralMass = theoreticalNeutralMass;
    return this;
  }

  public SmallMoleculeSummary addTheoreticalNeutralMassItem(Double theoreticalNeutralMassItem) {
    if (this.theoreticalNeutralMass == null) {
      this.theoreticalNeutralMass = new ArrayList<>();
    }
    this.theoreticalNeutralMass.add(theoreticalNeutralMassItem);
    return this;
  }

  /**
   * The small molecule’s precursor’s theoretical neutral mass.  The number of values provided MUST match the number of entities reported under “database_identifier”, and the validation software will throw an error if the number of “|” symbols does not match. “null” values (in general and between bars) are allowed for molecules that have not been identified only, or for molecules where the neutral mass cannot be calculated. In these cases, the SML entry SHOULD reference features in which exp_mass_to_charge values are captured. 
   * @return theoreticalNeutralMass
   */
  

  @JsonProperty(value = JSON_PROPERTY_THEORETICAL_NEUTRAL_MASS, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<Double> getTheoreticalNeutralMass() {
    return theoreticalNeutralMass;
  }


  @JsonProperty(value = JSON_PROPERTY_THEORETICAL_NEUTRAL_MASS, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTheoreticalNeutralMass( List<Double> theoreticalNeutralMass) {
    this.theoreticalNeutralMass = theoreticalNeutralMass;
  }


  public SmallMoleculeSummary adductIons( List<String> adductIons) {
    this.adductIons = adductIons;
    return this;
  }

  public SmallMoleculeSummary addAdductIonsItem(String adductIonsItem) {
    if (this.adductIons == null) {
      this.adductIons = new ArrayList<>();
    }
    this.adductIons.add(adductIonsItem);
    return this;
  }

  /**
   * A “|” separated list of detected adducts for this this molecule, following the general style in the 2013 IUPAC recommendations on terms relating to MS e.g. [M+H]1+, [M+Na]1+, [M+NH4]1+, [M-H]1-, [M+Cl]1-, [M+H]1+. If the adduct classification is ambiguous with regards to identification evidence it MAY be null. 
   * @return adductIons
   */
  

  @JsonProperty(value = JSON_PROPERTY_ADDUCT_IONS, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<String> getAdductIons() {
    return adductIons;
  }


  @JsonProperty(value = JSON_PROPERTY_ADDUCT_IONS, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAdductIons( List<String> adductIons) {
    this.adductIons = adductIons;
  }


  public SmallMoleculeSummary reliability( String reliability) {
    this.reliability = reliability;
    return this;
  }

  /**
   * The reliability of the given small molecule identification. This must be supplied by the resource and MUST be reported as an integer between 1-4:      identified metabolite (1)      putatively annotated compound (2)      putatively characterized compound class (3)      unknown compound (4)  These MAY be replaced using a suitable CV term in the metadata section e.g. to use MSI recommendation levels (see Section 6.2.57 for details).  The following CV terms are already available within the PSI MS CV. Future schemes may be implemented by extending the PSI MS CV with new terms and associated levels.  The MSI has recently discussed an extension of the original four level scheme into a five level scheme MS:1002896 (compound identification confidence level) with levels      isolated, pure compound, full stereochemistry (0)      reference standard match or full 2D structure (1)      unambiguous diagnostic evidence (literature, database) (2)      most likely structure, including isomers, substance class or substructure match (3)      unknown compound (4)  For high-resolution MS, the following term and its levels may be used: MS:1002955 (hr-ms compound identification confidence level) with levels      confirmed structure (1)      probable structure (2)          unambiguous ms library match (2a)          diagnostic evidence (2b)      tentative candidates (3)      unequivocal molecular formula (4)      exact mass (5)  A String data type is set to allow for different systems to be specified in the metadata section. 
   * @return reliability
   */
  

  @JsonProperty(value = JSON_PROPERTY_RELIABILITY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getReliability() {
    return reliability;
  }


  @JsonProperty(value = JSON_PROPERTY_RELIABILITY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setReliability( String reliability) {
    this.reliability = reliability;
  }


  public SmallMoleculeSummary bestIdConfidenceMeasure( Parameter bestIdConfidenceMeasure) {
    this.bestIdConfidenceMeasure = bestIdConfidenceMeasure;
    return this;
  }

  /**
   * Get bestIdConfidenceMeasure
   * @return bestIdConfidenceMeasure
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_BEST_ID_CONFIDENCE_MEASURE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Parameter getBestIdConfidenceMeasure() {
    return bestIdConfidenceMeasure;
  }


  @JsonProperty(value = JSON_PROPERTY_BEST_ID_CONFIDENCE_MEASURE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setBestIdConfidenceMeasure( Parameter bestIdConfidenceMeasure) {
    this.bestIdConfidenceMeasure = bestIdConfidenceMeasure;
  }


  public SmallMoleculeSummary bestIdConfidenceValue( Double bestIdConfidenceValue) {
    this.bestIdConfidenceValue = bestIdConfidenceValue;
    return this;
  }

  /**
   * The best confidence measure in identification (for this type of score) for the given small molecule across all assays. The type of score MUST be defined in the metadata section. If the small molecule was not identified by the specified search engine, “null” MUST be reported. If the confidence measure does not report a numerical confidence value, “null” SHOULD be reported.
   * @return bestIdConfidenceValue
   */
  

  @JsonProperty(value = JSON_PROPERTY_BEST_ID_CONFIDENCE_VALUE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Double getBestIdConfidenceValue() {
    return bestIdConfidenceValue;
  }


  @JsonProperty(value = JSON_PROPERTY_BEST_ID_CONFIDENCE_VALUE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setBestIdConfidenceValue( Double bestIdConfidenceValue) {
    this.bestIdConfidenceValue = bestIdConfidenceValue;
  }


  public SmallMoleculeSummary abundanceAssay( List<Double> abundanceAssay) {
    this.abundanceAssay = abundanceAssay;
    return this;
  }

  public SmallMoleculeSummary addAbundanceAssayItem(Double abundanceAssayItem) {
    if (this.abundanceAssay == null) {
      this.abundanceAssay = new ArrayList<>();
    }
    this.abundanceAssay.add(abundanceAssayItem);
    return this;
  }

  /**
   * The small molecule’s abundance in every assay described in the metadata section MUST be reported. Null or zero values may be reported as appropriate. \&quot;null\&quot; SHOULD be used to report missing quantities, while zero SHOULD be used to indicate a present but not reliably quantifiable value (e.g. below a minimum noise threshold).
   * @return abundanceAssay
   */
  

  @JsonProperty(value = JSON_PROPERTY_ABUNDANCE_ASSAY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<Double> getAbundanceAssay() {
    return abundanceAssay;
  }


  @JsonProperty(value = JSON_PROPERTY_ABUNDANCE_ASSAY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAbundanceAssay( List<Double> abundanceAssay) {
    this.abundanceAssay = abundanceAssay;
  }


  public SmallMoleculeSummary abundanceStudyVariable( List<Double> abundanceStudyVariable) {
    this.abundanceStudyVariable = abundanceStudyVariable;
    return this;
  }

  public SmallMoleculeSummary addAbundanceStudyVariableItem(Double abundanceStudyVariableItem) {
    if (this.abundanceStudyVariable == null) {
      this.abundanceStudyVariable = new ArrayList<>();
    }
    this.abundanceStudyVariable.add(abundanceStudyVariableItem);
    return this;
  }

  /**
   * The small molecule’s abundance in all the study variables described in the metadata section (study_variable[1-n]_average_function), calculated using the method as described in the Metadata section (default &#x3D; arithmetic mean across assays). Null or zero values may be reported as appropriate. \&quot;null\&quot; SHOULD be used to report missing quantities, while zero SHOULD be used to indicate a present but not reliably quantifiable value (e.g. below a minimum noise threshold).
   * @return abundanceStudyVariable
   */
  

  @JsonProperty(value = JSON_PROPERTY_ABUNDANCE_STUDY_VARIABLE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<Double> getAbundanceStudyVariable() {
    return abundanceStudyVariable;
  }


  @JsonProperty(value = JSON_PROPERTY_ABUNDANCE_STUDY_VARIABLE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAbundanceStudyVariable( List<Double> abundanceStudyVariable) {
    this.abundanceStudyVariable = abundanceStudyVariable;
  }


  public SmallMoleculeSummary abundanceVariationStudyVariable( List<Double> abundanceVariationStudyVariable) {
    this.abundanceVariationStudyVariable = abundanceVariationStudyVariable;
    return this;
  }

  public SmallMoleculeSummary addAbundanceVariationStudyVariableItem(Double abundanceVariationStudyVariableItem) {
    if (this.abundanceVariationStudyVariable == null) {
      this.abundanceVariationStudyVariable = new ArrayList<>();
    }
    this.abundanceVariationStudyVariable.add(abundanceVariationStudyVariableItem);
    return this;
  }

  /**
   * A measure of the variability of the study variable abundance measurement, calculated using the method as described in the metadata section (study_variable[1-n]_average_function), with a default &#x3D; arithmethic co-efficient of variation of the small molecule’s abundance in the given study variable.
   * @return abundanceVariationStudyVariable
   */
  

  @JsonProperty(value = JSON_PROPERTY_ABUNDANCE_VARIATION_STUDY_VARIABLE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<Double> getAbundanceVariationStudyVariable() {
    return abundanceVariationStudyVariable;
  }


  @JsonProperty(value = JSON_PROPERTY_ABUNDANCE_VARIATION_STUDY_VARIABLE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAbundanceVariationStudyVariable( List<Double> abundanceVariationStudyVariable) {
    this.abundanceVariationStudyVariable = abundanceVariationStudyVariable;
  }


  public SmallMoleculeSummary opt( List<@Valid OptColumnMapping> opt) {
    this.opt = opt;
    return this;
  }

  public SmallMoleculeSummary addOptItem(OptColumnMapping optItem) {
    if (this.opt == null) {
      this.opt = new ArrayList<>();
    }
    this.opt.add(optItem);
    return this;
  }

  /**
   * Additional columns can be added to the end of the small molecule table. These column headers MUST start with the prefix “opt_” followed by the {identifier} of the object they reference: assay, study variable, MS run or “global” (if the value relates to all replicates). Column names MUST only contain the following characters: ‘A’-‘Z’, ‘a’-‘z’, ‘0’-‘9’, ‘’, ‘-’, ‘[’, ‘]’, and ‘:’. CV parameter accessions MAY be used for optional columns following the format: opt{identifier}_cv_{accession}_\\{parameter name}. Spaces within the parameter’s name MUST be replaced by ‘_’. 
   * @return opt
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_OPT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid OptColumnMapping> getOpt() {
    return opt;
  }


  @JsonProperty(value = JSON_PROPERTY_OPT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOpt( List<@Valid OptColumnMapping> opt) {
    this.opt = opt;
  }


  public SmallMoleculeSummary comment( List<@Valid Comment> comment) {
    this.comment = comment;
    return this;
  }

  public SmallMoleculeSummary addCommentItem(Comment commentItem) {
    if (this.comment == null) {
      this.comment = new ArrayList<>();
    }
    this.comment.add(commentItem);
    return this;
  }

  /**
   * Get comment
   * @return comment
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_COMMENT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid Comment> getComment() {
    return comment;
  }


  @JsonProperty(value = JSON_PROPERTY_COMMENT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setComment( List<@Valid Comment> comment) {
    this.comment = comment;
  }


  /**
   * Return true if this SmallMoleculeSummary object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SmallMoleculeSummary smallMoleculeSummary = (SmallMoleculeSummary) o;
    return Objects.equals(this.prefix, smallMoleculeSummary.prefix) &&
        Objects.equals(this.headerPrefix, smallMoleculeSummary.headerPrefix) &&
        Objects.equals(this.smlId, smallMoleculeSummary.smlId) &&
        Objects.equals(this.smfIdRefs, smallMoleculeSummary.smfIdRefs) &&
        Objects.equals(this.databaseIdentifier, smallMoleculeSummary.databaseIdentifier) &&
        Objects.equals(this.chemicalFormula, smallMoleculeSummary.chemicalFormula) &&
        Objects.equals(this.smiles, smallMoleculeSummary.smiles) &&
        Objects.equals(this.inchi, smallMoleculeSummary.inchi) &&
        Objects.equals(this.chemicalName, smallMoleculeSummary.chemicalName) &&
        Objects.equals(this.uri, smallMoleculeSummary.uri) &&
        Objects.equals(this.theoreticalNeutralMass, smallMoleculeSummary.theoreticalNeutralMass) &&
        Objects.equals(this.adductIons, smallMoleculeSummary.adductIons) &&
        Objects.equals(this.reliability, smallMoleculeSummary.reliability) &&
        Objects.equals(this.bestIdConfidenceMeasure, smallMoleculeSummary.bestIdConfidenceMeasure) &&
        Objects.equals(this.bestIdConfidenceValue, smallMoleculeSummary.bestIdConfidenceValue) &&
        Objects.equals(this.abundanceAssay, smallMoleculeSummary.abundanceAssay) &&
        Objects.equals(this.abundanceStudyVariable, smallMoleculeSummary.abundanceStudyVariable) &&
        Objects.equals(this.abundanceVariationStudyVariable, smallMoleculeSummary.abundanceVariationStudyVariable) &&
        Objects.equals(this.opt, smallMoleculeSummary.opt) &&
        Objects.equals(this.comment, smallMoleculeSummary.comment);
  }

  @Override
  public int hashCode() {
    return Objects.hash(prefix, headerPrefix, smlId, smfIdRefs, databaseIdentifier, chemicalFormula, smiles, inchi, chemicalName, uri, theoreticalNeutralMass, adductIons, reliability, bestIdConfidenceMeasure, bestIdConfidenceValue, abundanceAssay, abundanceStudyVariable, abundanceVariationStudyVariable, opt, comment);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SmallMoleculeSummary {\n");
    sb.append("    prefix: ").append(toIndentedString(prefix)).append("\n");
    sb.append("    headerPrefix: ").append(toIndentedString(headerPrefix)).append("\n");
    sb.append("    smlId: ").append(toIndentedString(smlId)).append("\n");
    sb.append("    smfIdRefs: ").append(toIndentedString(smfIdRefs)).append("\n");
    sb.append("    databaseIdentifier: ").append(toIndentedString(databaseIdentifier)).append("\n");
    sb.append("    chemicalFormula: ").append(toIndentedString(chemicalFormula)).append("\n");
    sb.append("    smiles: ").append(toIndentedString(smiles)).append("\n");
    sb.append("    inchi: ").append(toIndentedString(inchi)).append("\n");
    sb.append("    chemicalName: ").append(toIndentedString(chemicalName)).append("\n");
    sb.append("    uri: ").append(toIndentedString(uri)).append("\n");
    sb.append("    theoreticalNeutralMass: ").append(toIndentedString(theoreticalNeutralMass)).append("\n");
    sb.append("    adductIons: ").append(toIndentedString(adductIons)).append("\n");
    sb.append("    reliability: ").append(toIndentedString(reliability)).append("\n");
    sb.append("    bestIdConfidenceMeasure: ").append(toIndentedString(bestIdConfidenceMeasure)).append("\n");
    sb.append("    bestIdConfidenceValue: ").append(toIndentedString(bestIdConfidenceValue)).append("\n");
    sb.append("    abundanceAssay: ").append(toIndentedString(abundanceAssay)).append("\n");
    sb.append("    abundanceStudyVariable: ").append(toIndentedString(abundanceStudyVariable)).append("\n");
    sb.append("    abundanceVariationStudyVariable: ").append(toIndentedString(abundanceVariationStudyVariable)).append("\n");
    sb.append("    opt: ").append(toIndentedString(opt)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

