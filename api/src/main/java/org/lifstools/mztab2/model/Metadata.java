/*
 * mzTab-M reference implementation and validation API.
 * This is the mzTab-M reference implementation and validation API service.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: nils.hoffmann@cebitec.uni-bielefeld.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.lifstools.mztab2.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import java.util.Locale;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.lifstools.mztab2.model.Assay;
import org.lifstools.mztab2.model.CV;
import org.lifstools.mztab2.model.ColumnParameterMapping;
import org.lifstools.mztab2.model.Contact;
import org.lifstools.mztab2.model.Database;
import org.lifstools.mztab2.model.Instrument;
import org.lifstools.mztab2.model.MsRun;
import org.lifstools.mztab2.model.Parameter;
import org.lifstools.mztab2.model.Publication;
import org.lifstools.mztab2.model.Sample;
import org.lifstools.mztab2.model.SampleProcessing;
import org.lifstools.mztab2.model.Software;
import org.lifstools.mztab2.model.StudyVariable;
import org.lifstools.mztab2.model.Uri;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import jakarta.validation.constraints.*;
import jakarta.validation.Valid;
import org.hibernate.validator.constraints.*;

/**
 * The metadata section provides additional information about the dataset(s) reported in the mzTab file. All fields in the metadata section are optional apart from those noted as mandatory. The fields in the metadata section MUST be reported in order of the various fields listed here. The field’s name and value MUST be separated by a tab character.  
 */
@JsonPropertyOrder({
  Metadata.JSON_PROPERTY_PREFIX,
  Metadata.JSON_PROPERTY_MZ_TAB_VERSION,
  Metadata.JSON_PROPERTY_MZ_TAB_I_D,
  Metadata.JSON_PROPERTY_TITLE,
  Metadata.JSON_PROPERTY_DESCRIPTION,
  Metadata.JSON_PROPERTY_CONTACT,
  Metadata.JSON_PROPERTY_PUBLICATION,
  Metadata.JSON_PROPERTY_URI,
  Metadata.JSON_PROPERTY_EXTERNAL_STUDY_URI,
  Metadata.JSON_PROPERTY_INSTRUMENT,
  Metadata.JSON_PROPERTY_QUANTIFICATION_METHOD,
  Metadata.JSON_PROPERTY_SAMPLE,
  Metadata.JSON_PROPERTY_SAMPLE_PROCESSING,
  Metadata.JSON_PROPERTY_SOFTWARE,
  Metadata.JSON_PROPERTY_DERIVATIZATION_AGENT,
  Metadata.JSON_PROPERTY_MS_RUN,
  Metadata.JSON_PROPERTY_ASSAY,
  Metadata.JSON_PROPERTY_STUDY_VARIABLE,
  Metadata.JSON_PROPERTY_CUSTOM,
  Metadata.JSON_PROPERTY_CV,
  Metadata.JSON_PROPERTY_SMALL_MOLECULE_QUANTIFICATION_UNIT,
  Metadata.JSON_PROPERTY_SMALL_MOLECULE_FEATURE_QUANTIFICATION_UNIT,
  Metadata.JSON_PROPERTY_SMALL_MOLECULE_IDENTIFICATION_RELIABILITY,
  Metadata.JSON_PROPERTY_DATABASE,
  Metadata.JSON_PROPERTY_ID_CONFIDENCE_MEASURE,
  Metadata.JSON_PROPERTY_COLUNIT_SMALL_MOLECULE,
  Metadata.JSON_PROPERTY_COLUNIT_SMALL_MOLECULE_FEATURE,
  Metadata.JSON_PROPERTY_COLUNIT_SMALL_MOLECULE_EVIDENCE
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-11-08T17:12:00.460651+01:00[Europe/Berlin]", comments = "Generator version: 7.17.0")
public class Metadata {

  /**
   * Property enumeration for Metadata.
   */
  public static enum Properties {
      prefix("prefix"), 
      mzTabVersion("mzTab-version"), 
      mzTabID("mzTab-ID"), 
      title("title"), 
      description("description"), 
      contact("contact"), 
      publication("publication"), 
      uri("uri"), 
      externalStudyUri("external_study_uri"), 
      instrument("instrument"), 
      quantificationMethod("quantification_method"), 
      sample("sample"), 
      sampleProcessing("sample_processing"), 
      software("software"), 
      derivatizationAgent("derivatization_agent"), 
      msRun("ms_run"), 
      assay("assay"), 
      studyVariable("study_variable"), 
      custom("custom"), 
      cv("cv"), 
      smallMoleculeQuantificationUnit("small_molecule-quantification_unit"), 
      smallMoleculeFeatureQuantificationUnit("small_molecule_feature-quantification_unit"), 
      smallMoleculeIdentificationReliability("small_molecule-identification_reliability"), 
      database("database"), 
      idConfidenceMeasure("id_confidence_measure"), 
      colunitSmallMolecule("colunit-small_molecule"), 
      colunitSmallMoleculeFeature("colunit-small_molecule_feature"), 
      colunitSmallMoleculeEvidence("colunit-small_molecule_evidence");

    private final String propertyName;

    private Properties(String propertyName) {
      this.propertyName = propertyName;
    }

    public String getPropertyName() {
      return propertyName;
    }

    public String toString() {
      return propertyName;
    }

    public String toUpper() {
      return propertyName.toUpperCase();
    }

    public static Properties of(String value) {
      if(value==null) {
        throw new NullPointerException("Argument value must not be null!");
      }
      return Arrays.asList(Properties.values()).stream().filter(m -> m.propertyName.equals(value.toLowerCase())).findAny().orElseThrow(IllegalArgumentException::new);
    }
  };
    
  /**
   * The metadata section prefix. MUST always be MTD. 
   */
  public enum PrefixEnum {
    MTD(String.valueOf("MTD"));

    private String value;

    PrefixEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static PrefixEnum fromValue(String value) {
      for (PrefixEnum b : PrefixEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_PREFIX = "prefix";
  @jakarta.validation.constraints.NotNull
  private PrefixEnum prefix = PrefixEnum.MTD;

  public static final String JSON_PROPERTY_MZ_TAB_VERSION = "mzTab-version";
  @jakarta.validation.constraints.NotNull
  private String mzTabVersion;

  public static final String JSON_PROPERTY_MZ_TAB_I_D = "mzTab-ID";
  @jakarta.validation.constraints.NotNull
  private String mzTabID;

  public static final String JSON_PROPERTY_TITLE = "title";
  
  private String title;

  public static final String JSON_PROPERTY_DESCRIPTION = "description";
  
  private String description;

  public static final String JSON_PROPERTY_CONTACT = "contact";
  
  private List<@Valid Contact> contact = new ArrayList<>();

  public static final String JSON_PROPERTY_PUBLICATION = "publication";
  
  private List<@Valid Publication> publication = new ArrayList<>();

  public static final String JSON_PROPERTY_URI = "uri";
  
  private List<@Valid Uri> uri = new ArrayList<>();

  public static final String JSON_PROPERTY_EXTERNAL_STUDY_URI = "external_study_uri";
  
  private List<@Valid Uri> externalStudyUri = new ArrayList<>();

  public static final String JSON_PROPERTY_INSTRUMENT = "instrument";
  
  private List<@Valid Instrument> instrument = new ArrayList<>();

  public static final String JSON_PROPERTY_QUANTIFICATION_METHOD = "quantification_method";
  @jakarta.validation.constraints.NotNull
  private Parameter quantificationMethod;

  public static final String JSON_PROPERTY_SAMPLE = "sample";
  
  private List<@Valid Sample> sample = new ArrayList<>();

  public static final String JSON_PROPERTY_SAMPLE_PROCESSING = "sample_processing";
  
  private List<@Valid SampleProcessing> sampleProcessing = new ArrayList<>();

  public static final String JSON_PROPERTY_SOFTWARE = "software";
  @jakarta.validation.constraints.NotNull
  private List<@Valid Software> software = new ArrayList<>();

  public static final String JSON_PROPERTY_DERIVATIZATION_AGENT = "derivatization_agent";
  
  private List<@Valid Parameter> derivatizationAgent = new ArrayList<>();

  public static final String JSON_PROPERTY_MS_RUN = "ms_run";
  @jakarta.validation.constraints.NotNull
  private List<@Valid MsRun> msRun = new ArrayList<>();

  public static final String JSON_PROPERTY_ASSAY = "assay";
  @jakarta.validation.constraints.NotNull
  private List<@Valid Assay> assay = new ArrayList<>();

  public static final String JSON_PROPERTY_STUDY_VARIABLE = "study_variable";
  @jakarta.validation.constraints.NotNull
  private List<@Valid StudyVariable> studyVariable = new ArrayList<>();

  public static final String JSON_PROPERTY_CUSTOM = "custom";
  
  private List<@Valid Parameter> custom = new ArrayList<>();

  public static final String JSON_PROPERTY_CV = "cv";
  @jakarta.validation.constraints.NotNull
  private List<@Valid CV> cv = new ArrayList<>();

  public static final String JSON_PROPERTY_SMALL_MOLECULE_QUANTIFICATION_UNIT = "small_molecule-quantification_unit";
  @jakarta.validation.constraints.NotNull
  private Parameter smallMoleculeQuantificationUnit;

  public static final String JSON_PROPERTY_SMALL_MOLECULE_FEATURE_QUANTIFICATION_UNIT = "small_molecule_feature-quantification_unit";
  @jakarta.validation.constraints.NotNull
  private Parameter smallMoleculeFeatureQuantificationUnit;

  public static final String JSON_PROPERTY_SMALL_MOLECULE_IDENTIFICATION_RELIABILITY = "small_molecule-identification_reliability";
  
  private Parameter smallMoleculeIdentificationReliability;

  public static final String JSON_PROPERTY_DATABASE = "database";
  @jakarta.validation.constraints.NotNull
  private List<@Valid Database> database = new ArrayList<>();

  public static final String JSON_PROPERTY_ID_CONFIDENCE_MEASURE = "id_confidence_measure";
  @jakarta.validation.constraints.NotNull
  private List<@Valid Parameter> idConfidenceMeasure = new ArrayList<>();

  public static final String JSON_PROPERTY_COLUNIT_SMALL_MOLECULE = "colunit-small_molecule";
  
  private List<@Valid ColumnParameterMapping> colunitSmallMolecule = new ArrayList<>();

  public static final String JSON_PROPERTY_COLUNIT_SMALL_MOLECULE_FEATURE = "colunit-small_molecule_feature";
  
  private List<@Valid ColumnParameterMapping> colunitSmallMoleculeFeature = new ArrayList<>();

  public static final String JSON_PROPERTY_COLUNIT_SMALL_MOLECULE_EVIDENCE = "colunit-small_molecule_evidence";
  
  private List<@Valid ColumnParameterMapping> colunitSmallMoleculeEvidence = new ArrayList<>();

  public Metadata() { 
  }

  public Metadata prefix(@jakarta.validation.constraints.NotNull PrefixEnum prefix) {
    this.prefix = prefix;
    return this;
  }

  /**
   * The metadata section prefix. MUST always be MTD. 
   * @return prefix
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @JsonProperty(value = JSON_PROPERTY_PREFIX, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public PrefixEnum getPrefix() {
    return prefix;
  }


  @JsonProperty(value = JSON_PROPERTY_PREFIX, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setPrefix(@jakarta.validation.constraints.NotNull PrefixEnum prefix) {
    this.prefix = prefix;
  }


  public Metadata mzTabVersion(@jakarta.validation.constraints.NotNull String mzTabVersion) {
    this.mzTabVersion = mzTabVersion;
    return this;
  }

  /**
   * The version of the mzTab file. The suffix MUST be \&quot;-M\&quot; for mzTab for metabolomics (mzTab-M). 
   * @return mzTabVersion
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Pattern(regexp="^\\d{1}\\.\\d{1}\\.\\d{1}-[A-Z]{1}$")
  @JsonProperty(value = JSON_PROPERTY_MZ_TAB_VERSION, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getMzTabVersion() {
    return mzTabVersion;
  }


  @JsonProperty(value = JSON_PROPERTY_MZ_TAB_VERSION, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMzTabVersion(@jakarta.validation.constraints.NotNull String mzTabVersion) {
    this.mzTabVersion = mzTabVersion;
  }


  public Metadata mzTabID(@jakarta.validation.constraints.NotNull String mzTabID) {
    this.mzTabID = mzTabID;
    return this;
  }

  /**
   * The ID of the mzTab file, this could be supplied by the repository from which it is downloaded or a local identifier from the lab producing the file. It is not intended to be a globally unique ID but carry some locally useful meaning. 
   * @return mzTabID
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @JsonProperty(value = JSON_PROPERTY_MZ_TAB_I_D, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getMzTabID() {
    return mzTabID;
  }


  @JsonProperty(value = JSON_PROPERTY_MZ_TAB_I_D, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMzTabID(@jakarta.validation.constraints.NotNull String mzTabID) {
    this.mzTabID = mzTabID;
  }


  public Metadata title( String title) {
    this.title = title;
    return this;
  }

  /**
   * The file’s human readable title. 
   * @return title
   */
  

  @JsonProperty(value = JSON_PROPERTY_TITLE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getTitle() {
    return title;
  }


  @JsonProperty(value = JSON_PROPERTY_TITLE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setTitle( String title) {
    this.title = title;
  }


  public Metadata description( String description) {
    this.description = description;
    return this;
  }

  /**
   * The file’s human readable description. 
   * @return description
   */
  

  @JsonProperty(value = JSON_PROPERTY_DESCRIPTION, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getDescription() {
    return description;
  }


  @JsonProperty(value = JSON_PROPERTY_DESCRIPTION, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDescription( String description) {
    this.description = description;
  }


  public Metadata contact( List<@Valid Contact> contact) {
    this.contact = contact;
    return this;
  }

  public Metadata addContactItem(Contact contactItem) {
    if (this.contact == null) {
      this.contact = new ArrayList<>();
    }
    this.contact.add(contactItem);
    return this;
  }

  /**
   * The contact’s name, affiliation and e-mail. Several contacts can be given by indicating the number in the square brackets after \&quot;contact\&quot;. A contact has to be supplied in the format [first name] [initials] [last name].
   * @return contact
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_CONTACT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid Contact> getContact() {
    return contact;
  }


  @JsonProperty(value = JSON_PROPERTY_CONTACT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setContact( List<@Valid Contact> contact) {
    this.contact = contact;
  }


  public Metadata publication( List<@Valid Publication> publication) {
    this.publication = publication;
    return this;
  }

  public Metadata addPublicationItem(Publication publicationItem) {
    if (this.publication == null) {
      this.publication = new ArrayList<>();
    }
    this.publication.add(publicationItem);
    return this;
  }

  /**
   * A publication associated with this file. Several publications can be given by indicating the number in the square brackets after “publication”. PubMed ids must be prefixed by “pubmed:”, DOIs by “doi:”. Multiple identifiers MUST be separated by “|”.
   * @return publication
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_PUBLICATION, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid Publication> getPublication() {
    return publication;
  }


  @JsonProperty(value = JSON_PROPERTY_PUBLICATION, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setPublication( List<@Valid Publication> publication) {
    this.publication = publication;
  }


  public Metadata uri( List<@Valid Uri> uri) {
    this.uri = uri;
    return this;
  }

  public Metadata addUriItem(Uri uriItem) {
    if (this.uri == null) {
      this.uri = new ArrayList<>();
    }
    this.uri.add(uriItem);
    return this;
  }

  /**
   * A URI pointing to the file’s source data (e.g., a MetaboLights records).
   * @return uri
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_URI, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid Uri> getUri() {
    return uri;
  }


  @JsonProperty(value = JSON_PROPERTY_URI, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUri( List<@Valid Uri> uri) {
    this.uri = uri;
  }


  public Metadata externalStudyUri( List<@Valid Uri> externalStudyUri) {
    this.externalStudyUri = externalStudyUri;
    return this;
  }

  public Metadata addExternalStudyUriItem(Uri externalStudyUriItem) {
    if (this.externalStudyUri == null) {
      this.externalStudyUri = new ArrayList<>();
    }
    this.externalStudyUri.add(externalStudyUriItem);
    return this;
  }

  /**
   * A URI pointing to an external file with more details about the study design (e.g., an ISA-TAB file).
   * @return externalStudyUri
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_EXTERNAL_STUDY_URI, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid Uri> getExternalStudyUri() {
    return externalStudyUri;
  }


  @JsonProperty(value = JSON_PROPERTY_EXTERNAL_STUDY_URI, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setExternalStudyUri( List<@Valid Uri> externalStudyUri) {
    this.externalStudyUri = externalStudyUri;
  }


  public Metadata instrument( List<@Valid Instrument> instrument) {
    this.instrument = instrument;
    return this;
  }

  public Metadata addInstrumentItem(Instrument instrumentItem) {
    if (this.instrument == null) {
      this.instrument = new ArrayList<>();
    }
    this.instrument.add(instrumentItem);
    return this;
  }

  /**
   * The name, source, analyzer and detector of the instruments used in the experiment. Multiple instruments are numbered [1-n].
   * @return instrument
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_INSTRUMENT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid Instrument> getInstrument() {
    return instrument;
  }


  @JsonProperty(value = JSON_PROPERTY_INSTRUMENT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setInstrument( List<@Valid Instrument> instrument) {
    this.instrument = instrument;
  }


  public Metadata quantificationMethod(@jakarta.validation.constraints.NotNull Parameter quantificationMethod) {
    this.quantificationMethod = quantificationMethod;
    return this;
  }

  /**
   * Get quantificationMethod
   * @return quantificationMethod
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_QUANTIFICATION_METHOD, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Parameter getQuantificationMethod() {
    return quantificationMethod;
  }


  @JsonProperty(value = JSON_PROPERTY_QUANTIFICATION_METHOD, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setQuantificationMethod(@jakarta.validation.constraints.NotNull Parameter quantificationMethod) {
    this.quantificationMethod = quantificationMethod;
  }


  public Metadata sample( List<@Valid Sample> sample) {
    this.sample = sample;
    return this;
  }

  public Metadata addSampleItem(Sample sampleItem) {
    if (this.sample == null) {
      this.sample = new ArrayList<>();
    }
    this.sample.add(sampleItem);
    return this;
  }

  /**
   * Specification of sample. (empty) name: A name for each sample to serve as a list of the samples that MUST be reported in the following tables. Samples MUST be reported if a statistical design is being captured (i.e. bio or tech replicates). If the type of replicates are not known, samples SHOULD NOT be reported.  species: The respective species of the samples analysed. For more complex cases, such as metagenomics, optional columns and userParams should be used.  tissue: The respective tissue(s) of the sample.  cell_type: The respective cell type(s) of the sample.  disease: The respective disease(s) of the sample.  description: A human readable description of the sample.  custom: Custom parameters describing the sample’s additional properties. Dates MUST be provided in ISO-8601 format. 
   * @return sample
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_SAMPLE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid Sample> getSample() {
    return sample;
  }


  @JsonProperty(value = JSON_PROPERTY_SAMPLE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSample( List<@Valid Sample> sample) {
    this.sample = sample;
  }


  public Metadata sampleProcessing( List<@Valid SampleProcessing> sampleProcessing) {
    this.sampleProcessing = sampleProcessing;
    return this;
  }

  public Metadata addSampleProcessingItem(SampleProcessing sampleProcessingItem) {
    if (this.sampleProcessing == null) {
      this.sampleProcessing = new ArrayList<>();
    }
    this.sampleProcessing.add(sampleProcessingItem);
    return this;
  }

  /**
   * A list of parameters describing a sample processing, preparation or handling step similar to a biological or analytical methods report. The order of the sample_processing items should reflect the order these processing steps were performed in. If multiple parameters are given for a step these MUST be separated by a “|”. If derivatization was performed, it MUST be reported here as a general step, e.g. &#39;silylation&#39; and the actual derivatization agens MUST be specified in the Section 6.2.54 part. 
   * @return sampleProcessing
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_SAMPLE_PROCESSING, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid SampleProcessing> getSampleProcessing() {
    return sampleProcessing;
  }


  @JsonProperty(value = JSON_PROPERTY_SAMPLE_PROCESSING, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSampleProcessing( List<@Valid SampleProcessing> sampleProcessing) {
    this.sampleProcessing = sampleProcessing;
  }


  public Metadata software(@jakarta.validation.constraints.NotNull List<@Valid Software> software) {
    this.software = software;
    return this;
  }

  public Metadata addSoftwareItem(Software softwareItem) {
    if (this.software == null) {
      this.software = new ArrayList<>();
    }
    this.software.add(softwareItem);
    return this;
  }

  /**
   * Software used to analyze the data and obtain the reported results. The parameter’s value SHOULD contain the software’s version. The order (numbering) should reflect the order in which the tools were used. A software setting used. This field MAY occur multiple times for a single software. The value of this field is deliberately set as a String, since there currently do not exist CV terms for every possible setting.
   * @return software
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_SOFTWARE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<@Valid Software> getSoftware() {
    return software;
  }


  @JsonProperty(value = JSON_PROPERTY_SOFTWARE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSoftware(@jakarta.validation.constraints.NotNull List<@Valid Software> software) {
    this.software = software;
  }


  public Metadata derivatizationAgent( List<@Valid Parameter> derivatizationAgent) {
    this.derivatizationAgent = derivatizationAgent;
    return this;
  }

  public Metadata addDerivatizationAgentItem(Parameter derivatizationAgentItem) {
    if (this.derivatizationAgent == null) {
      this.derivatizationAgent = new ArrayList<>();
    }
    this.derivatizationAgent.add(derivatizationAgentItem);
    return this;
  }

  /**
   * A description of derivatization agents applied to small molecules, using userParams or CV terms where possible.
   * @return derivatizationAgent
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_DERIVATIZATION_AGENT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid Parameter> getDerivatizationAgent() {
    return derivatizationAgent;
  }


  @JsonProperty(value = JSON_PROPERTY_DERIVATIZATION_AGENT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDerivatizationAgent( List<@Valid Parameter> derivatizationAgent) {
    this.derivatizationAgent = derivatizationAgent;
  }


  public Metadata msRun(@jakarta.validation.constraints.NotNull List<@Valid MsRun> msRun) {
    this.msRun = msRun;
    return this;
  }

  public Metadata addMsRunItem(MsRun msRunItem) {
    if (this.msRun == null) {
      this.msRun = new ArrayList<>();
    }
    this.msRun.add(msRunItem);
    return this;
  }

  /**
   * Specification of ms_run.  location: Location of the external data file e.g. raw files on which analysis has been performed. If the actual location of the MS run is unknown, a “null” MUST be used as a place holder value, since the [1-n] cardinality is referenced elsewhere. If pre-fractionation has been performed, then [1-n] ms_runs SHOULD be created per assay.  instrument_ref: If different instruments are used in different runs, instrument_ref can be used to link a specific instrument to a specific run.  format: Parameter specifying the data format of the external MS data file. If ms_run[1-n]-format is present, ms_run[1-n]-id_format SHOULD also be present, following the parameters specified in Table 1.  id_format: Parameter specifying the id format used in the external data file. If ms_run[1-n]-id_format is present, ms_run[1-n]-format SHOULD also be present. fragmentation_method: The type(s) of fragmentation used in a given ms run. scan_polarity: The polarity mode of a given run. Usually only one value SHOULD be given here except for the case of mixed polarity runs. hash: Hash value of the corresponding external MS data file defined in ms_run[1-n]-location. If ms_run[1-n]-hash is present, ms_run[1-n]-hash_method SHOULD also be present. hash_method: A parameter specifying the hash methods used to generate the String in ms_run[1-n]-hash. Specifics of the hash method used MAY follow the definitions of the mzML format. If ms_run[1-n]-hash is present, ms_run[1-n]-hash_method SHOULD also be present. 
   * @return msRun
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_MS_RUN, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<@Valid MsRun> getMsRun() {
    return msRun;
  }


  @JsonProperty(value = JSON_PROPERTY_MS_RUN, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMsRun(@jakarta.validation.constraints.NotNull List<@Valid MsRun> msRun) {
    this.msRun = msRun;
  }


  public Metadata assay(@jakarta.validation.constraints.NotNull List<@Valid Assay> assay) {
    this.assay = assay;
    return this;
  }

  public Metadata addAssayItem(Assay assayItem) {
    if (this.assay == null) {
      this.assay = new ArrayList<>();
    }
    this.assay.add(assayItem);
    return this;
  }

  /**
   * Specification of assay. (empty) name: A name for each assay, to serve as a list of the assays that MUST be reported in the following tables.  custom: Additional custom parameters or values for a given assay.  external_uri: An external reference uri to further information about the assay, for example via a reference to an object within an ISA-TAB file.  sample_ref: An association from a given assay to the sample analysed.  ms_run_ref: An association from a given assay to the source MS run. All assays MUST reference exactly one ms_run unless a workflow with pre-fractionation is being encoded, in which case each assay MUST reference n ms_runs where n fractions have been collected. Multiple assays SHOULD reference the same ms_run to capture multiplexed experimental designs. 
   * @return assay
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_ASSAY, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<@Valid Assay> getAssay() {
    return assay;
  }


  @JsonProperty(value = JSON_PROPERTY_ASSAY, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setAssay(@jakarta.validation.constraints.NotNull List<@Valid Assay> assay) {
    this.assay = assay;
  }


  public Metadata studyVariable(@jakarta.validation.constraints.NotNull List<@Valid StudyVariable> studyVariable) {
    this.studyVariable = studyVariable;
    return this;
  }

  public Metadata addStudyVariableItem(StudyVariable studyVariableItem) {
    if (this.studyVariable == null) {
      this.studyVariable = new ArrayList<>();
    }
    this.studyVariable.add(studyVariableItem);
    return this;
  }

  /**
   * Specification of study_variable. (empty) name: A name for each study variable (experimental condition or factor), to serve as a list of the study variables that MUST be reported in the following tables. For software that does not capture study variables, a single study variable MUST be reported, linking to all assays. This single study variable MUST have the identifier “undefined“. assay_refs: Bar-separated references to the IDs of assays grouped in the study variable. average_function: The function used to calculate the study variable quantification value and the operation used is not arithmetic mean (default) e.g. “geometric mean”, “median”. The 1-n refers to different study variables. variation_function: The function used to calculate the study variable quantification variation value if it is reported and the operation used is not coefficient of variation (default) e.g. “standard error”. description: A textual description of the study variable. factors: Additional parameters or factors, separated by bars, that are known about study variables allowing the capture of more complex, such as nested designs. 
   * @return studyVariable
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_STUDY_VARIABLE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<@Valid StudyVariable> getStudyVariable() {
    return studyVariable;
  }


  @JsonProperty(value = JSON_PROPERTY_STUDY_VARIABLE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setStudyVariable(@jakarta.validation.constraints.NotNull List<@Valid StudyVariable> studyVariable) {
    this.studyVariable = studyVariable;
  }


  public Metadata custom( List<@Valid Parameter> custom) {
    this.custom = custom;
    return this;
  }

  public Metadata addCustomItem(Parameter customItem) {
    if (this.custom == null) {
      this.custom = new ArrayList<>();
    }
    this.custom.add(customItem);
    return this;
  }

  /**
   * Any additional parameters describing the analysis reported.
   * @return custom
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_CUSTOM, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid Parameter> getCustom() {
    return custom;
  }


  @JsonProperty(value = JSON_PROPERTY_CUSTOM, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setCustom( List<@Valid Parameter> custom) {
    this.custom = custom;
  }


  public Metadata cv(@jakarta.validation.constraints.NotNull List<@Valid CV> cv) {
    this.cv = cv;
    return this;
  }

  public Metadata addCvItem(CV cvItem) {
    if (this.cv == null) {
      this.cv = new ArrayList<>();
    }
    this.cv.add(cvItem);
    return this;
  }

  /**
   * Specification of controlled vocabularies. label: A string describing the labels of the controlled vocabularies/ontologies used in the mzTab file as a short-hand e.g. \&quot;MS\&quot; for PSI-MS. full_name: A string describing the full names of the controlled vocabularies/ontologies used in the mzTab file. version: A string describing the version of the controlled vocabularies/ontologies used in the mzTab file. uri: A string containing the URIs of the controlled vocabularies/ontologies used in the mzTab file. 
   * @return cv
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_CV, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<@Valid CV> getCv() {
    return cv;
  }


  @JsonProperty(value = JSON_PROPERTY_CV, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCv(@jakarta.validation.constraints.NotNull List<@Valid CV> cv) {
    this.cv = cv;
  }


  public Metadata smallMoleculeQuantificationUnit(@jakarta.validation.constraints.NotNull Parameter smallMoleculeQuantificationUnit) {
    this.smallMoleculeQuantificationUnit = smallMoleculeQuantificationUnit;
    return this;
  }

  /**
   * Get smallMoleculeQuantificationUnit
   * @return smallMoleculeQuantificationUnit
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_SMALL_MOLECULE_QUANTIFICATION_UNIT, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Parameter getSmallMoleculeQuantificationUnit() {
    return smallMoleculeQuantificationUnit;
  }


  @JsonProperty(value = JSON_PROPERTY_SMALL_MOLECULE_QUANTIFICATION_UNIT, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSmallMoleculeQuantificationUnit(@jakarta.validation.constraints.NotNull Parameter smallMoleculeQuantificationUnit) {
    this.smallMoleculeQuantificationUnit = smallMoleculeQuantificationUnit;
  }


  public Metadata smallMoleculeFeatureQuantificationUnit(@jakarta.validation.constraints.NotNull Parameter smallMoleculeFeatureQuantificationUnit) {
    this.smallMoleculeFeatureQuantificationUnit = smallMoleculeFeatureQuantificationUnit;
    return this;
  }

  /**
   * Get smallMoleculeFeatureQuantificationUnit
   * @return smallMoleculeFeatureQuantificationUnit
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_SMALL_MOLECULE_FEATURE_QUANTIFICATION_UNIT, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Parameter getSmallMoleculeFeatureQuantificationUnit() {
    return smallMoleculeFeatureQuantificationUnit;
  }


  @JsonProperty(value = JSON_PROPERTY_SMALL_MOLECULE_FEATURE_QUANTIFICATION_UNIT, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSmallMoleculeFeatureQuantificationUnit(@jakarta.validation.constraints.NotNull Parameter smallMoleculeFeatureQuantificationUnit) {
    this.smallMoleculeFeatureQuantificationUnit = smallMoleculeFeatureQuantificationUnit;
  }


  public Metadata smallMoleculeIdentificationReliability( Parameter smallMoleculeIdentificationReliability) {
    this.smallMoleculeIdentificationReliability = smallMoleculeIdentificationReliability;
    return this;
  }

  /**
   * Get smallMoleculeIdentificationReliability
   * @return smallMoleculeIdentificationReliability
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_SMALL_MOLECULE_IDENTIFICATION_RELIABILITY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Parameter getSmallMoleculeIdentificationReliability() {
    return smallMoleculeIdentificationReliability;
  }


  @JsonProperty(value = JSON_PROPERTY_SMALL_MOLECULE_IDENTIFICATION_RELIABILITY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSmallMoleculeIdentificationReliability( Parameter smallMoleculeIdentificationReliability) {
    this.smallMoleculeIdentificationReliability = smallMoleculeIdentificationReliability;
  }


  public Metadata database(@jakarta.validation.constraints.NotNull List<@Valid Database> database) {
    this.database = database;
    return this;
  }

  public Metadata addDatabaseItem(Database databaseItem) {
    if (this.database == null) {
      this.database = new ArrayList<>();
    }
    this.database.add(databaseItem);
    return this;
  }

  /**
   * Specification of databases. (empty): The description of databases used. For cases, where a known database has not been used for identification, a userParam SHOULD be inserted to describe any identification performed e.g. de novo. If no identification has been performed at all then \&quot;no database\&quot; should be inserted followed by null. prefix: The prefix used in the “identifier” column of data tables. For the “no database” case \&quot;null\&quot; must be used. version: The database version is mandatory where identification has been performed. This may be a formal version number e.g. “1.4.1”, a date of access “2016-10-27” (ISO-8601 format) or “Unknown” if there is no suitable version that can be annotated. uri: The URI to the database. For the “no database” case, \&quot;null\&quot; must be reported. 
   * @return database
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_DATABASE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<@Valid Database> getDatabase() {
    return database;
  }


  @JsonProperty(value = JSON_PROPERTY_DATABASE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setDatabase(@jakarta.validation.constraints.NotNull List<@Valid Database> database) {
    this.database = database;
  }


  public Metadata idConfidenceMeasure(@jakarta.validation.constraints.NotNull List<@Valid Parameter> idConfidenceMeasure) {
    this.idConfidenceMeasure = idConfidenceMeasure;
    return this;
  }

  public Metadata addIdConfidenceMeasureItem(Parameter idConfidenceMeasureItem) {
    if (this.idConfidenceMeasure == null) {
      this.idConfidenceMeasure = new ArrayList<>();
    }
    this.idConfidenceMeasure.add(idConfidenceMeasureItem);
    return this;
  }

  /**
   * The type of small molecule confidence measures or scores MUST be reported as a CV parameter [1-n]. The CV parameter definition should formally state whether the ordering is high to low or vice versa. The order of the scores SHOULD reflect their importance for the identification and be used to determine the identification’s rank.
   * @return idConfidenceMeasure
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_ID_CONFIDENCE_MEASURE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<@Valid Parameter> getIdConfidenceMeasure() {
    return idConfidenceMeasure;
  }


  @JsonProperty(value = JSON_PROPERTY_ID_CONFIDENCE_MEASURE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setIdConfidenceMeasure(@jakarta.validation.constraints.NotNull List<@Valid Parameter> idConfidenceMeasure) {
    this.idConfidenceMeasure = idConfidenceMeasure;
  }


  public Metadata colunitSmallMolecule( List<@Valid ColumnParameterMapping> colunitSmallMolecule) {
    this.colunitSmallMolecule = colunitSmallMolecule;
    return this;
  }

  public Metadata addColunitSmallMoleculeItem(ColumnParameterMapping colunitSmallMoleculeItem) {
    if (this.colunitSmallMolecule == null) {
      this.colunitSmallMolecule = new ArrayList<>();
    }
    this.colunitSmallMolecule.add(colunitSmallMoleculeItem);
    return this;
  }

  /**
   * Defines the used unit for a column in the small molecule section. The format of the value has to be \\{column name}&#x3D;\\{Parameter defining the unit}. This field MUST NOT be used to define a unit for quantification columns. The unit used for small molecule quantification values MUST be set in small_molecule-quantification_unit.
   * @return colunitSmallMolecule
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_COLUNIT_SMALL_MOLECULE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid ColumnParameterMapping> getColunitSmallMolecule() {
    return colunitSmallMolecule;
  }


  @JsonProperty(value = JSON_PROPERTY_COLUNIT_SMALL_MOLECULE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setColunitSmallMolecule( List<@Valid ColumnParameterMapping> colunitSmallMolecule) {
    this.colunitSmallMolecule = colunitSmallMolecule;
  }


  public Metadata colunitSmallMoleculeFeature( List<@Valid ColumnParameterMapping> colunitSmallMoleculeFeature) {
    this.colunitSmallMoleculeFeature = colunitSmallMoleculeFeature;
    return this;
  }

  public Metadata addColunitSmallMoleculeFeatureItem(ColumnParameterMapping colunitSmallMoleculeFeatureItem) {
    if (this.colunitSmallMoleculeFeature == null) {
      this.colunitSmallMoleculeFeature = new ArrayList<>();
    }
    this.colunitSmallMoleculeFeature.add(colunitSmallMoleculeFeatureItem);
    return this;
  }

  /**
   * Defines the used unit for a column in the small molecule feature section. The format of the value has to be \\{column name}&#x3D;\\{Parameter defining the unit}. This field MUST NOT be used to define a unit for quantification columns. The unit used for small molecule quantification values MUST be set in small_molecule_feature-quantification_unit.
   * @return colunitSmallMoleculeFeature
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_COLUNIT_SMALL_MOLECULE_FEATURE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid ColumnParameterMapping> getColunitSmallMoleculeFeature() {
    return colunitSmallMoleculeFeature;
  }


  @JsonProperty(value = JSON_PROPERTY_COLUNIT_SMALL_MOLECULE_FEATURE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setColunitSmallMoleculeFeature( List<@Valid ColumnParameterMapping> colunitSmallMoleculeFeature) {
    this.colunitSmallMoleculeFeature = colunitSmallMoleculeFeature;
  }


  public Metadata colunitSmallMoleculeEvidence( List<@Valid ColumnParameterMapping> colunitSmallMoleculeEvidence) {
    this.colunitSmallMoleculeEvidence = colunitSmallMoleculeEvidence;
    return this;
  }

  public Metadata addColunitSmallMoleculeEvidenceItem(ColumnParameterMapping colunitSmallMoleculeEvidenceItem) {
    if (this.colunitSmallMoleculeEvidence == null) {
      this.colunitSmallMoleculeEvidence = new ArrayList<>();
    }
    this.colunitSmallMoleculeEvidence.add(colunitSmallMoleculeEvidenceItem);
    return this;
  }

  /**
   * Defines the used unit for a column in the small molecule evidence section. The format of the value has to be \\{column name}&#x3D;\\{Parameter defining the unit}.
   * @return colunitSmallMoleculeEvidence
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_COLUNIT_SMALL_MOLECULE_EVIDENCE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid ColumnParameterMapping> getColunitSmallMoleculeEvidence() {
    return colunitSmallMoleculeEvidence;
  }


  @JsonProperty(value = JSON_PROPERTY_COLUNIT_SMALL_MOLECULE_EVIDENCE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setColunitSmallMoleculeEvidence( List<@Valid ColumnParameterMapping> colunitSmallMoleculeEvidence) {
    this.colunitSmallMoleculeEvidence = colunitSmallMoleculeEvidence;
  }


  /**
   * Return true if this Metadata object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    Metadata metadata = (Metadata) o;
    return Objects.equals(this.prefix, metadata.prefix) &&
        Objects.equals(this.mzTabVersion, metadata.mzTabVersion) &&
        Objects.equals(this.mzTabID, metadata.mzTabID) &&
        Objects.equals(this.title, metadata.title) &&
        Objects.equals(this.description, metadata.description) &&
        Objects.equals(this.contact, metadata.contact) &&
        Objects.equals(this.publication, metadata.publication) &&
        Objects.equals(this.uri, metadata.uri) &&
        Objects.equals(this.externalStudyUri, metadata.externalStudyUri) &&
        Objects.equals(this.instrument, metadata.instrument) &&
        Objects.equals(this.quantificationMethod, metadata.quantificationMethod) &&
        Objects.equals(this.sample, metadata.sample) &&
        Objects.equals(this.sampleProcessing, metadata.sampleProcessing) &&
        Objects.equals(this.software, metadata.software) &&
        Objects.equals(this.derivatizationAgent, metadata.derivatizationAgent) &&
        Objects.equals(this.msRun, metadata.msRun) &&
        Objects.equals(this.assay, metadata.assay) &&
        Objects.equals(this.studyVariable, metadata.studyVariable) &&
        Objects.equals(this.custom, metadata.custom) &&
        Objects.equals(this.cv, metadata.cv) &&
        Objects.equals(this.smallMoleculeQuantificationUnit, metadata.smallMoleculeQuantificationUnit) &&
        Objects.equals(this.smallMoleculeFeatureQuantificationUnit, metadata.smallMoleculeFeatureQuantificationUnit) &&
        Objects.equals(this.smallMoleculeIdentificationReliability, metadata.smallMoleculeIdentificationReliability) &&
        Objects.equals(this.database, metadata.database) &&
        Objects.equals(this.idConfidenceMeasure, metadata.idConfidenceMeasure) &&
        Objects.equals(this.colunitSmallMolecule, metadata.colunitSmallMolecule) &&
        Objects.equals(this.colunitSmallMoleculeFeature, metadata.colunitSmallMoleculeFeature) &&
        Objects.equals(this.colunitSmallMoleculeEvidence, metadata.colunitSmallMoleculeEvidence);
  }

  @Override
  public int hashCode() {
    return Objects.hash(prefix, mzTabVersion, mzTabID, title, description, contact, publication, uri, externalStudyUri, instrument, quantificationMethod, sample, sampleProcessing, software, derivatizationAgent, msRun, assay, studyVariable, custom, cv, smallMoleculeQuantificationUnit, smallMoleculeFeatureQuantificationUnit, smallMoleculeIdentificationReliability, database, idConfidenceMeasure, colunitSmallMolecule, colunitSmallMoleculeFeature, colunitSmallMoleculeEvidence);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class Metadata {\n");
    sb.append("    prefix: ").append(toIndentedString(prefix)).append("\n");
    sb.append("    mzTabVersion: ").append(toIndentedString(mzTabVersion)).append("\n");
    sb.append("    mzTabID: ").append(toIndentedString(mzTabID)).append("\n");
    sb.append("    title: ").append(toIndentedString(title)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    contact: ").append(toIndentedString(contact)).append("\n");
    sb.append("    publication: ").append(toIndentedString(publication)).append("\n");
    sb.append("    uri: ").append(toIndentedString(uri)).append("\n");
    sb.append("    externalStudyUri: ").append(toIndentedString(externalStudyUri)).append("\n");
    sb.append("    instrument: ").append(toIndentedString(instrument)).append("\n");
    sb.append("    quantificationMethod: ").append(toIndentedString(quantificationMethod)).append("\n");
    sb.append("    sample: ").append(toIndentedString(sample)).append("\n");
    sb.append("    sampleProcessing: ").append(toIndentedString(sampleProcessing)).append("\n");
    sb.append("    software: ").append(toIndentedString(software)).append("\n");
    sb.append("    derivatizationAgent: ").append(toIndentedString(derivatizationAgent)).append("\n");
    sb.append("    msRun: ").append(toIndentedString(msRun)).append("\n");
    sb.append("    assay: ").append(toIndentedString(assay)).append("\n");
    sb.append("    studyVariable: ").append(toIndentedString(studyVariable)).append("\n");
    sb.append("    custom: ").append(toIndentedString(custom)).append("\n");
    sb.append("    cv: ").append(toIndentedString(cv)).append("\n");
    sb.append("    smallMoleculeQuantificationUnit: ").append(toIndentedString(smallMoleculeQuantificationUnit)).append("\n");
    sb.append("    smallMoleculeFeatureQuantificationUnit: ").append(toIndentedString(smallMoleculeFeatureQuantificationUnit)).append("\n");
    sb.append("    smallMoleculeIdentificationReliability: ").append(toIndentedString(smallMoleculeIdentificationReliability)).append("\n");
    sb.append("    database: ").append(toIndentedString(database)).append("\n");
    sb.append("    idConfidenceMeasure: ").append(toIndentedString(idConfidenceMeasure)).append("\n");
    sb.append("    colunitSmallMolecule: ").append(toIndentedString(colunitSmallMolecule)).append("\n");
    sb.append("    colunitSmallMoleculeFeature: ").append(toIndentedString(colunitSmallMoleculeFeature)).append("\n");
    sb.append("    colunitSmallMoleculeEvidence: ").append(toIndentedString(colunitSmallMoleculeEvidence)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

