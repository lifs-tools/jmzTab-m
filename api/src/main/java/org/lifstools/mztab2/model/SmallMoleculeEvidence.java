/*
 * mzTab-M reference implementation and validation API.
 * This is the mzTab-M reference implementation and validation API service.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: nils.hoffmann@cebitec.uni-bielefeld.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.lifstools.mztab2.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import java.util.Locale;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.net.URI;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.lifstools.mztab2.model.Comment;
import org.lifstools.mztab2.model.OptColumnMapping;
import org.lifstools.mztab2.model.Parameter;
import org.lifstools.mztab2.model.SpectraRef;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import jakarta.validation.constraints.*;
import jakarta.validation.Valid;
import org.hibernate.validator.constraints.*;

/**
 * The small molecule evidence section is table-based, representing evidence for identifications of small molecules/features, from database search or any other process used to give putative identifications to molecules. In a typical case, each row represents one result from a single search or intepretation of a piece of evidence e.g. a database search with a fragmentation spectrum. Multiple results from a given input data item (e.g. one fragment spectrum) SHOULD share the same value under evidence_input_id.  The small molecule evidence section MUST always come after the Small Molecule Feature Table. All table columns MUST be Tab separated. There MUST NOT be any empty cells. Missing values MUST be reported using “null”.  The order of columns MUST follow the order specified below.  All columns are MANDATORY except for “opt_” columns. 
 */
@JsonPropertyOrder({
  SmallMoleculeEvidence.JSON_PROPERTY_PREFIX,
  SmallMoleculeEvidence.JSON_PROPERTY_HEADER_PREFIX,
  SmallMoleculeEvidence.JSON_PROPERTY_SME_ID,
  SmallMoleculeEvidence.JSON_PROPERTY_EVIDENCE_INPUT_ID,
  SmallMoleculeEvidence.JSON_PROPERTY_DATABASE_IDENTIFIER,
  SmallMoleculeEvidence.JSON_PROPERTY_CHEMICAL_FORMULA,
  SmallMoleculeEvidence.JSON_PROPERTY_SMILES,
  SmallMoleculeEvidence.JSON_PROPERTY_INCHI,
  SmallMoleculeEvidence.JSON_PROPERTY_CHEMICAL_NAME,
  SmallMoleculeEvidence.JSON_PROPERTY_URI,
  SmallMoleculeEvidence.JSON_PROPERTY_DERIVATIZED_FORM,
  SmallMoleculeEvidence.JSON_PROPERTY_ADDUCT_ION,
  SmallMoleculeEvidence.JSON_PROPERTY_EXP_MASS_TO_CHARGE,
  SmallMoleculeEvidence.JSON_PROPERTY_CHARGE,
  SmallMoleculeEvidence.JSON_PROPERTY_THEORETICAL_MASS_TO_CHARGE,
  SmallMoleculeEvidence.JSON_PROPERTY_SPECTRA_REF,
  SmallMoleculeEvidence.JSON_PROPERTY_IDENTIFICATION_METHOD,
  SmallMoleculeEvidence.JSON_PROPERTY_MS_LEVEL,
  SmallMoleculeEvidence.JSON_PROPERTY_ID_CONFIDENCE_MEASURE,
  SmallMoleculeEvidence.JSON_PROPERTY_RANK,
  SmallMoleculeEvidence.JSON_PROPERTY_OPT,
  SmallMoleculeEvidence.JSON_PROPERTY_COMMENT
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-11-08T17:12:00.460651+01:00[Europe/Berlin]", comments = "Generator version: 7.17.0")
public class SmallMoleculeEvidence {

  /**
   * Property enumeration for SmallMoleculeEvidence.
   */
  public static enum Properties {
      prefix("prefix"), 
      headerPrefix("header_prefix"), 
      smeId("sme_id"), 
      evidenceInputId("evidence_input_id"), 
      databaseIdentifier("database_identifier"), 
      chemicalFormula("chemical_formula"), 
      smiles("smiles"), 
      inchi("inchi"), 
      chemicalName("chemical_name"), 
      uri("uri"), 
      derivatizedForm("derivatized_form"), 
      adductIon("adduct_ion"), 
      expMassToCharge("exp_mass_to_charge"), 
      charge("charge"), 
      theoreticalMassToCharge("theoretical_mass_to_charge"), 
      spectraRef("spectra_ref"), 
      identificationMethod("identification_method"), 
      msLevel("ms_level"), 
      idConfidenceMeasure("id_confidence_measure"), 
      rank("rank"), 
      opt("opt"), 
      comment("comment");

    private final String propertyName;

    private Properties(String propertyName) {
      this.propertyName = propertyName;
    }

    public String getPropertyName() {
      return propertyName;
    }

    public String toString() {
      return propertyName;
    }

    public String toUpper() {
      return propertyName.toUpperCase();
    }

    public static Properties of(String value) {
      if(value==null) {
        throw new NullPointerException("Argument value must not be null!");
      }
      return Arrays.asList(Properties.values()).stream().filter(m -> m.propertyName.equals(value.toLowerCase())).findAny().orElseThrow(IllegalArgumentException::new);
    }
  };
  
  /**
   * The small molecule evidence table row prefix. SME MUST be used for rows of the small molecule evidence table.
   */
  public enum PrefixEnum {
    SME(String.valueOf("SME"));

    private String value;

    PrefixEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static PrefixEnum fromValue(String value) {
      for (PrefixEnum b : PrefixEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_PREFIX = "prefix";
  
  private PrefixEnum prefix = PrefixEnum.SME;

  /**
   * The small molecule evidence table header prefix. SEH MUST be used for the small molecule evidence table header line (the column labels).
   */
  public enum HeaderPrefixEnum {
    SEH(String.valueOf("SEH"));

    private String value;

    HeaderPrefixEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static HeaderPrefixEnum fromValue(String value) {
      for (HeaderPrefixEnum b : HeaderPrefixEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_HEADER_PREFIX = "header_prefix";
  
  private HeaderPrefixEnum headerPrefix = HeaderPrefixEnum.SEH;

  public static final String JSON_PROPERTY_SME_ID = "sme_id";
  @jakarta.validation.constraints.NotNull
  private Integer smeId;

  public static final String JSON_PROPERTY_EVIDENCE_INPUT_ID = "evidence_input_id";
  @jakarta.validation.constraints.NotNull
  private String evidenceInputId;

  public static final String JSON_PROPERTY_DATABASE_IDENTIFIER = "database_identifier";
  @jakarta.validation.constraints.NotNull
  private String databaseIdentifier;

  public static final String JSON_PROPERTY_CHEMICAL_FORMULA = "chemical_formula";
  
  private String chemicalFormula;

  public static final String JSON_PROPERTY_SMILES = "smiles";
  
  private String smiles;

  public static final String JSON_PROPERTY_INCHI = "inchi";
  
  private String inchi;

  public static final String JSON_PROPERTY_CHEMICAL_NAME = "chemical_name";
  
  private String chemicalName;

  public static final String JSON_PROPERTY_URI = "uri";
  
  private URI uri;

  public static final String JSON_PROPERTY_DERIVATIZED_FORM = "derivatized_form";
  
  private Parameter derivatizedForm;

  public static final String JSON_PROPERTY_ADDUCT_ION = "adduct_ion";
  
  private String adductIon;

  public static final String JSON_PROPERTY_EXP_MASS_TO_CHARGE = "exp_mass_to_charge";
  @jakarta.validation.constraints.NotNull
  private Double expMassToCharge;

  public static final String JSON_PROPERTY_CHARGE = "charge";
  @jakarta.validation.constraints.NotNull
  private Integer charge;

  public static final String JSON_PROPERTY_THEORETICAL_MASS_TO_CHARGE = "theoretical_mass_to_charge";
  @jakarta.validation.constraints.NotNull
  private Double theoreticalMassToCharge;

  public static final String JSON_PROPERTY_SPECTRA_REF = "spectra_ref";
  @jakarta.validation.constraints.NotNull
  private List<@Valid SpectraRef> spectraRef = new ArrayList<>();

  public static final String JSON_PROPERTY_IDENTIFICATION_METHOD = "identification_method";
  @jakarta.validation.constraints.NotNull
  private Parameter identificationMethod;

  public static final String JSON_PROPERTY_MS_LEVEL = "ms_level";
  @jakarta.validation.constraints.NotNull
  private Parameter msLevel;

  public static final String JSON_PROPERTY_ID_CONFIDENCE_MEASURE = "id_confidence_measure";
  
  private List<Double> idConfidenceMeasure = new ArrayList<>();

  public static final String JSON_PROPERTY_RANK = "rank";
  @jakarta.validation.constraints.NotNull
  private Integer rank = 1;

  public static final String JSON_PROPERTY_OPT = "opt";
  
  private List<@Valid OptColumnMapping> opt = new ArrayList<>();

  public static final String JSON_PROPERTY_COMMENT = "comment";
  
  private List<@Valid Comment> comment = new ArrayList<>();

  public SmallMoleculeEvidence() { 
  }

  @JsonCreator
  public SmallMoleculeEvidence(
    @JsonProperty(JSON_PROPERTY_PREFIX) PrefixEnum prefix, 
    @JsonProperty(JSON_PROPERTY_HEADER_PREFIX) HeaderPrefixEnum headerPrefix
  ) {
  this();
    this.prefix = prefix;
    this.headerPrefix = headerPrefix;
  }

  /**
   * The small molecule evidence table row prefix. SME MUST be used for rows of the small molecule evidence table.
   * @return prefix
   */
  

  @JsonProperty(value = JSON_PROPERTY_PREFIX, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public PrefixEnum getPrefix() {
    return prefix;
  }




  /**
   * The small molecule evidence table header prefix. SEH MUST be used for the small molecule evidence table header line (the column labels).
   * @return headerPrefix
   */
  

  @JsonProperty(value = JSON_PROPERTY_HEADER_PREFIX, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public HeaderPrefixEnum getHeaderPrefix() {
    return headerPrefix;
  }




  public SmallMoleculeEvidence smeId(@jakarta.validation.constraints.NotNull Integer smeId) {
    this.smeId = smeId;
    return this;
  }

  /**
   * A within file unique identifier for the small molecule evidence result.
   * @return smeId
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @JsonProperty(value = JSON_PROPERTY_SME_ID, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Integer getSmeId() {
    return smeId;
  }


  @JsonProperty(value = JSON_PROPERTY_SME_ID, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSmeId(@jakarta.validation.constraints.NotNull Integer smeId) {
    this.smeId = smeId;
  }


  public SmallMoleculeEvidence evidenceInputId(@jakarta.validation.constraints.NotNull String evidenceInputId) {
    this.evidenceInputId = evidenceInputId;
    return this;
  }

  /**
   * A within file unique identifier for the input data used to support this identification e.g. fragment spectrum, RT and m/z pair, isotope profile that was used for the identification process, to serve as a grouping mechanism, whereby multiple rows of results from the same input data share the same ID. The identifiers may be human readable but should not be assumed to be interpretable. For example, if fragmentation spectra have been searched then the ID may be the spectrum reference, or for accurate mass search, the ms_run[2]:458.75.
   * @return evidenceInputId
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @JsonProperty(value = JSON_PROPERTY_EVIDENCE_INPUT_ID, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getEvidenceInputId() {
    return evidenceInputId;
  }


  @JsonProperty(value = JSON_PROPERTY_EVIDENCE_INPUT_ID, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setEvidenceInputId(@jakarta.validation.constraints.NotNull String evidenceInputId) {
    this.evidenceInputId = evidenceInputId;
  }


  public SmallMoleculeEvidence databaseIdentifier(@jakarta.validation.constraints.NotNull String databaseIdentifier) {
    this.databaseIdentifier = databaseIdentifier;
    return this;
  }

  /**
   * The putative identification for the small molecule sourced from an external database, using the same prefix specified in database[1-n]-prefix.  This could include additionally a chemical class or an identifier to a spectral library entity, even if its actual identity is unknown.  For the “no database” case, \&quot;null\&quot; must be used. The unprefixed use of \&quot;null\&quot; is prohibited for any other case. If no putative identification can be reported for a particular database, it MUST be reported as the database prefix followed by null. 
   * @return databaseIdentifier
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @JsonProperty(value = JSON_PROPERTY_DATABASE_IDENTIFIER, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public String getDatabaseIdentifier() {
    return databaseIdentifier;
  }


  @JsonProperty(value = JSON_PROPERTY_DATABASE_IDENTIFIER, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setDatabaseIdentifier(@jakarta.validation.constraints.NotNull String databaseIdentifier) {
    this.databaseIdentifier = databaseIdentifier;
  }


  public SmallMoleculeEvidence chemicalFormula( String chemicalFormula) {
    this.chemicalFormula = chemicalFormula;
    return this;
  }

  /**
   * The chemical formula of the identified compound e.g. in a database, assumed to match the theoretical mass to charge (in some cases this will be the derivatized form, including adducts and protons).  This should be specified in Hill notation (EA Hill 1900), i.e. elements in the order C, H and then alphabetically all other elements. Counts of one may be omitted. Elements should be capitalized properly to avoid confusion (e.g., “CO” vs. “Co”). The chemical formula reported should refer to the neutral form. Charge state is reported by the charge field.  Example N-acetylglucosamine would be encoded by the string “C8H15NO6” 
   * @return chemicalFormula
   */
  

  @JsonProperty(value = JSON_PROPERTY_CHEMICAL_FORMULA, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getChemicalFormula() {
    return chemicalFormula;
  }


  @JsonProperty(value = JSON_PROPERTY_CHEMICAL_FORMULA, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setChemicalFormula( String chemicalFormula) {
    this.chemicalFormula = chemicalFormula;
  }


  public SmallMoleculeEvidence smiles( String smiles) {
    this.smiles = smiles;
    return this;
  }

  /**
   * The potential molecule’s structure in the simplified molecular-input line-entry system (SMILES) for the small molecule.
   * @return smiles
   */
  

  @JsonProperty(value = JSON_PROPERTY_SMILES, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getSmiles() {
    return smiles;
  }


  @JsonProperty(value = JSON_PROPERTY_SMILES, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSmiles( String smiles) {
    this.smiles = smiles;
  }


  public SmallMoleculeEvidence inchi( String inchi) {
    this.inchi = inchi;
    return this;
  }

  /**
   * A standard IUPAC International Chemical Identifier (InChI) for the given substance.
   * @return inchi
   */
  

  @JsonProperty(value = JSON_PROPERTY_INCHI, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getInchi() {
    return inchi;
  }


  @JsonProperty(value = JSON_PROPERTY_INCHI, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setInchi( String inchi) {
    this.inchi = inchi;
  }


  public SmallMoleculeEvidence chemicalName( String chemicalName) {
    this.chemicalName = chemicalName;
    return this;
  }

  /**
   * The small molecule’s chemical/common name, or general description if a chemical name is unavailable.
   * @return chemicalName
   */
  

  @JsonProperty(value = JSON_PROPERTY_CHEMICAL_NAME, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getChemicalName() {
    return chemicalName;
  }


  @JsonProperty(value = JSON_PROPERTY_CHEMICAL_NAME, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setChemicalName( String chemicalName) {
    this.chemicalName = chemicalName;
  }


  public SmallMoleculeEvidence uri( URI uri) {
    this.uri = uri;
    return this;
  }

  /**
   * A URI pointing to the small molecule’s entry in a database (e.g., the small molecule’s HMDB, Chebi or KEGG entry).
   * @return uri
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_URI, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public URI getUri() {
    return uri;
  }


  @JsonProperty(value = JSON_PROPERTY_URI, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setUri( URI uri) {
    this.uri = uri;
  }


  public SmallMoleculeEvidence derivatizedForm( Parameter derivatizedForm) {
    this.derivatizedForm = derivatizedForm;
    return this;
  }

  /**
   * Get derivatizedForm
   * @return derivatizedForm
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_DERIVATIZED_FORM, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Parameter getDerivatizedForm() {
    return derivatizedForm;
  }


  @JsonProperty(value = JSON_PROPERTY_DERIVATIZED_FORM, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setDerivatizedForm( Parameter derivatizedForm) {
    this.derivatizedForm = derivatizedForm;
  }


  public SmallMoleculeEvidence adductIon( String adductIon) {
    this.adductIon = adductIon;
    return this;
  }

  /**
   * The assumed classification of this molecule’s adduct ion after detection, following the general style in the 2013 IUPAC recommendations on terms relating to MS e.g. [M+H]+, [M+Na]1+, [M+NH4]1+, [M-H]1-, [M+Cl]1-. If the adduct classification is ambiguous with regards to identification evidence it MAY be null.
   * @return adductIon
   */
  
  @Pattern(regexp="^\\[\\d*M([+-][\\w\\d]+)*\\]\\d*[+-]$")
  @JsonProperty(value = JSON_PROPERTY_ADDUCT_ION, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getAdductIon() {
    return adductIon;
  }


  @JsonProperty(value = JSON_PROPERTY_ADDUCT_ION, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAdductIon( String adductIon) {
    this.adductIon = adductIon;
  }


  public SmallMoleculeEvidence expMassToCharge(@jakarta.validation.constraints.NotNull Double expMassToCharge) {
    this.expMassToCharge = expMassToCharge;
    return this;
  }

  /**
   * The experimental mass/charge value for the precursor ion. If multiple adduct forms have been combined into a single identification event/search, then a single value e.g. for the protonated form SHOULD be reported here.
   * @return expMassToCharge
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @JsonProperty(value = JSON_PROPERTY_EXP_MASS_TO_CHARGE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Double getExpMassToCharge() {
    return expMassToCharge;
  }


  @JsonProperty(value = JSON_PROPERTY_EXP_MASS_TO_CHARGE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setExpMassToCharge(@jakarta.validation.constraints.NotNull Double expMassToCharge) {
    this.expMassToCharge = expMassToCharge;
  }


  public SmallMoleculeEvidence charge(@jakarta.validation.constraints.NotNull Integer charge) {
    this.charge = charge;
    return this;
  }

  /**
   * The small molecule evidence’s charge value using positive integers both for positive and negative polarity modes.
   * @return charge
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @JsonProperty(value = JSON_PROPERTY_CHARGE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Integer getCharge() {
    return charge;
  }


  @JsonProperty(value = JSON_PROPERTY_CHARGE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCharge(@jakarta.validation.constraints.NotNull Integer charge) {
    this.charge = charge;
  }


  public SmallMoleculeEvidence theoreticalMassToCharge(@jakarta.validation.constraints.NotNull Double theoreticalMassToCharge) {
    this.theoreticalMassToCharge = theoreticalMassToCharge;
    return this;
  }

  /**
   * The theoretical mass/charge value for the small molecule or the database mass/charge value (for a spectral library match).
   * @return theoreticalMassToCharge
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @JsonProperty(value = JSON_PROPERTY_THEORETICAL_MASS_TO_CHARGE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Double getTheoreticalMassToCharge() {
    return theoreticalMassToCharge;
  }


  @JsonProperty(value = JSON_PROPERTY_THEORETICAL_MASS_TO_CHARGE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setTheoreticalMassToCharge(@jakarta.validation.constraints.NotNull Double theoreticalMassToCharge) {
    this.theoreticalMassToCharge = theoreticalMassToCharge;
  }


  public SmallMoleculeEvidence spectraRef(@jakarta.validation.constraints.NotNull List<@Valid SpectraRef> spectraRef) {
    this.spectraRef = spectraRef;
    return this;
  }

  public SmallMoleculeEvidence addSpectraRefItem(SpectraRef spectraRefItem) {
    if (this.spectraRef == null) {
      this.spectraRef = new ArrayList<>();
    }
    this.spectraRef.add(spectraRefItem);
    return this;
  }

  /**
   * Reference to a spectrum in a spectrum file, for example a fragmentation spectrum has been used to support the identification. If a separate spectrum file has been used for fragmentation spectrum, this MUST be reported in the metadata section as additional ms_runs. The reference must be in the format ms_run[1-n]:{SPECTRA_REF} where SPECTRA_REF MUST follow the format defined in 5.2 (including references to chromatograms where these are used to inform identification). Multiple spectra MUST be referenced using a “|” delimited list for the (rare) cases in which search engines have combined or aggregated multiple spectra in advance of the search to make identifications.  If a fragmentation spectrum has not been used, the value should indicate the ms_run to which is identification is mapped e.g. “ms_run[1]”. 
   * @return spectraRef
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_SPECTRA_REF, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<@Valid SpectraRef> getSpectraRef() {
    return spectraRef;
  }


  @JsonProperty(value = JSON_PROPERTY_SPECTRA_REF, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSpectraRef(@jakarta.validation.constraints.NotNull List<@Valid SpectraRef> spectraRef) {
    this.spectraRef = spectraRef;
  }


  public SmallMoleculeEvidence identificationMethod(@jakarta.validation.constraints.NotNull Parameter identificationMethod) {
    this.identificationMethod = identificationMethod;
    return this;
  }

  /**
   * Get identificationMethod
   * @return identificationMethod
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_IDENTIFICATION_METHOD, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Parameter getIdentificationMethod() {
    return identificationMethod;
  }


  @JsonProperty(value = JSON_PROPERTY_IDENTIFICATION_METHOD, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setIdentificationMethod(@jakarta.validation.constraints.NotNull Parameter identificationMethod) {
    this.identificationMethod = identificationMethod;
  }


  public SmallMoleculeEvidence msLevel(@jakarta.validation.constraints.NotNull Parameter msLevel) {
    this.msLevel = msLevel;
    return this;
  }

  /**
   * Get msLevel
   * @return msLevel
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_MS_LEVEL, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Parameter getMsLevel() {
    return msLevel;
  }


  @JsonProperty(value = JSON_PROPERTY_MS_LEVEL, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMsLevel(@jakarta.validation.constraints.NotNull Parameter msLevel) {
    this.msLevel = msLevel;
  }


  public SmallMoleculeEvidence idConfidenceMeasure( List<Double> idConfidenceMeasure) {
    this.idConfidenceMeasure = idConfidenceMeasure;
    return this;
  }

  public SmallMoleculeEvidence addIdConfidenceMeasureItem(Double idConfidenceMeasureItem) {
    if (this.idConfidenceMeasure == null) {
      this.idConfidenceMeasure = new ArrayList<>();
    }
    this.idConfidenceMeasure.add(idConfidenceMeasureItem);
    return this;
  }

  /**
   * Any statistical value or score for the identification. The metadata section reports the type of score used, as id_confidence_measure[1-n] of type Param.
   * @return idConfidenceMeasure
   */
  

  @JsonProperty(value = JSON_PROPERTY_ID_CONFIDENCE_MEASURE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<Double> getIdConfidenceMeasure() {
    return idConfidenceMeasure;
  }


  @JsonProperty(value = JSON_PROPERTY_ID_CONFIDENCE_MEASURE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIdConfidenceMeasure( List<Double> idConfidenceMeasure) {
    this.idConfidenceMeasure = idConfidenceMeasure;
  }


  public SmallMoleculeEvidence rank(@jakarta.validation.constraints.NotNull Integer rank) {
    this.rank = rank;
    return this;
  }

  /**
   * The rank of this identification from this approach as increasing integers from 1 (best ranked identification). Ties (equal score) are represented by using the same rank – defaults to 1 if there is no ranking system used.
   * minimum: 1
   * @return rank
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Min(1)
  @JsonProperty(value = JSON_PROPERTY_RANK, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Integer getRank() {
    return rank;
  }


  @JsonProperty(value = JSON_PROPERTY_RANK, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setRank(@jakarta.validation.constraints.NotNull Integer rank) {
    this.rank = rank;
  }


  public SmallMoleculeEvidence opt( List<@Valid OptColumnMapping> opt) {
    this.opt = opt;
    return this;
  }

  public SmallMoleculeEvidence addOptItem(OptColumnMapping optItem) {
    if (this.opt == null) {
      this.opt = new ArrayList<>();
    }
    this.opt.add(optItem);
    return this;
  }

  /**
   * Additional columns can be added to the end of the small molecule evidence table. These column headers MUST start with the prefix “opt_” followed by the {identifier} of the object they reference: assay, study variable, MS run or “global” (if the value relates to all replicates). Column names MUST only contain the following characters: ‘A’-‘Z’, ‘a’-‘z’, ‘0’-‘9’, ‘’, ‘-’, ‘[’, ‘]’, and ‘:’. CV parameter accessions MAY be used for optional columns following the format: opt{identifier}_cv_{accession}_\\{parameter name}. Spaces within the parameter’s name MUST be replaced by ‘_’. 
   * @return opt
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_OPT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid OptColumnMapping> getOpt() {
    return opt;
  }


  @JsonProperty(value = JSON_PROPERTY_OPT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOpt( List<@Valid OptColumnMapping> opt) {
    this.opt = opt;
  }


  public SmallMoleculeEvidence comment( List<@Valid Comment> comment) {
    this.comment = comment;
    return this;
  }

  public SmallMoleculeEvidence addCommentItem(Comment commentItem) {
    if (this.comment == null) {
      this.comment = new ArrayList<>();
    }
    this.comment.add(commentItem);
    return this;
  }

  /**
   * Get comment
   * @return comment
   */
  
  @Valid

  @JsonProperty(value = JSON_PROPERTY_COMMENT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid Comment> getComment() {
    return comment;
  }


  @JsonProperty(value = JSON_PROPERTY_COMMENT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setComment( List<@Valid Comment> comment) {
    this.comment = comment;
  }


  /**
   * Return true if this SmallMoleculeEvidence object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SmallMoleculeEvidence smallMoleculeEvidence = (SmallMoleculeEvidence) o;
    return Objects.equals(this.prefix, smallMoleculeEvidence.prefix) &&
        Objects.equals(this.headerPrefix, smallMoleculeEvidence.headerPrefix) &&
        Objects.equals(this.smeId, smallMoleculeEvidence.smeId) &&
        Objects.equals(this.evidenceInputId, smallMoleculeEvidence.evidenceInputId) &&
        Objects.equals(this.databaseIdentifier, smallMoleculeEvidence.databaseIdentifier) &&
        Objects.equals(this.chemicalFormula, smallMoleculeEvidence.chemicalFormula) &&
        Objects.equals(this.smiles, smallMoleculeEvidence.smiles) &&
        Objects.equals(this.inchi, smallMoleculeEvidence.inchi) &&
        Objects.equals(this.chemicalName, smallMoleculeEvidence.chemicalName) &&
        Objects.equals(this.uri, smallMoleculeEvidence.uri) &&
        Objects.equals(this.derivatizedForm, smallMoleculeEvidence.derivatizedForm) &&
        Objects.equals(this.adductIon, smallMoleculeEvidence.adductIon) &&
        Objects.equals(this.expMassToCharge, smallMoleculeEvidence.expMassToCharge) &&
        Objects.equals(this.charge, smallMoleculeEvidence.charge) &&
        Objects.equals(this.theoreticalMassToCharge, smallMoleculeEvidence.theoreticalMassToCharge) &&
        Objects.equals(this.spectraRef, smallMoleculeEvidence.spectraRef) &&
        Objects.equals(this.identificationMethod, smallMoleculeEvidence.identificationMethod) &&
        Objects.equals(this.msLevel, smallMoleculeEvidence.msLevel) &&
        Objects.equals(this.idConfidenceMeasure, smallMoleculeEvidence.idConfidenceMeasure) &&
        Objects.equals(this.rank, smallMoleculeEvidence.rank) &&
        Objects.equals(this.opt, smallMoleculeEvidence.opt) &&
        Objects.equals(this.comment, smallMoleculeEvidence.comment);
  }

  @Override
  public int hashCode() {
    return Objects.hash(prefix, headerPrefix, smeId, evidenceInputId, databaseIdentifier, chemicalFormula, smiles, inchi, chemicalName, uri, derivatizedForm, adductIon, expMassToCharge, charge, theoreticalMassToCharge, spectraRef, identificationMethod, msLevel, idConfidenceMeasure, rank, opt, comment);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SmallMoleculeEvidence {\n");
    sb.append("    prefix: ").append(toIndentedString(prefix)).append("\n");
    sb.append("    headerPrefix: ").append(toIndentedString(headerPrefix)).append("\n");
    sb.append("    smeId: ").append(toIndentedString(smeId)).append("\n");
    sb.append("    evidenceInputId: ").append(toIndentedString(evidenceInputId)).append("\n");
    sb.append("    databaseIdentifier: ").append(toIndentedString(databaseIdentifier)).append("\n");
    sb.append("    chemicalFormula: ").append(toIndentedString(chemicalFormula)).append("\n");
    sb.append("    smiles: ").append(toIndentedString(smiles)).append("\n");
    sb.append("    inchi: ").append(toIndentedString(inchi)).append("\n");
    sb.append("    chemicalName: ").append(toIndentedString(chemicalName)).append("\n");
    sb.append("    uri: ").append(toIndentedString(uri)).append("\n");
    sb.append("    derivatizedForm: ").append(toIndentedString(derivatizedForm)).append("\n");
    sb.append("    adductIon: ").append(toIndentedString(adductIon)).append("\n");
    sb.append("    expMassToCharge: ").append(toIndentedString(expMassToCharge)).append("\n");
    sb.append("    charge: ").append(toIndentedString(charge)).append("\n");
    sb.append("    theoreticalMassToCharge: ").append(toIndentedString(theoreticalMassToCharge)).append("\n");
    sb.append("    spectraRef: ").append(toIndentedString(spectraRef)).append("\n");
    sb.append("    identificationMethod: ").append(toIndentedString(identificationMethod)).append("\n");
    sb.append("    msLevel: ").append(toIndentedString(msLevel)).append("\n");
    sb.append("    idConfidenceMeasure: ").append(toIndentedString(idConfidenceMeasure)).append("\n");
    sb.append("    rank: ").append(toIndentedString(rank)).append("\n");
    sb.append("    opt: ").append(toIndentedString(opt)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

