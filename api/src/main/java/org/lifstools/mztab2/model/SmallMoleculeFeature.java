/*
 * mzTab-M reference implementation and validation API.
 * This is the mzTab-M reference implementation and validation API service.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: nils.hoffmann@cebitec.uni-bielefeld.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.lifstools.mztab2.model;

import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import com.fasterxml.jackson.annotation.JsonValue;
import jakarta.validation.Valid;
import jakarta.validation.constraints.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Objects;

/**
 * The small molecule feature section is table-based, representing individual MS regions (generally considered to be the elution profile for all isotopomers formed from a single charge state of a molecule), that have been measured/quantified. However, for approaches that quantify individual isotopomers e.g. stable isotope labelling/flux studies, then each SMF row SHOULD represent a single isotopomer.  Different adducts or derivatives and different charge states of individual molecules should be reported as separate SMF rows.  The small molecule feature section MUST always come after the Small Molecule Table. All table columns MUST be Tab separated. There MUST NOT be any empty cells. Missing values MUST be reported using “null”.  The order of columns MUST follow the order specified below.  All columns are MANDATORY except for “opt_” columns. 
 */
@JsonPropertyOrder({
  SmallMoleculeFeature.JSON_PROPERTY_PREFIX,
  SmallMoleculeFeature.JSON_PROPERTY_HEADER_PREFIX,
  SmallMoleculeFeature.JSON_PROPERTY_SMF_ID,
  SmallMoleculeFeature.JSON_PROPERTY_SME_ID_REFS,
  SmallMoleculeFeature.JSON_PROPERTY_SME_ID_REF_AMBIGUITY_CODE,
  SmallMoleculeFeature.JSON_PROPERTY_ADDUCT_ION,
  SmallMoleculeFeature.JSON_PROPERTY_ISOTOPOMER,
  SmallMoleculeFeature.JSON_PROPERTY_EXP_MASS_TO_CHARGE,
  SmallMoleculeFeature.JSON_PROPERTY_CHARGE,
  SmallMoleculeFeature.JSON_PROPERTY_RETENTION_TIME_IN_SECONDS,
  SmallMoleculeFeature.JSON_PROPERTY_RETENTION_TIME_IN_SECONDS_START,
  SmallMoleculeFeature.JSON_PROPERTY_RETENTION_TIME_IN_SECONDS_END,
  SmallMoleculeFeature.JSON_PROPERTY_ABUNDANCE_ASSAY,
  SmallMoleculeFeature.JSON_PROPERTY_OPT,
  SmallMoleculeFeature.JSON_PROPERTY_COMMENT
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-11-08T17:12:00.460651+01:00[Europe/Berlin]", comments = "Generator version: 7.17.0")
public class SmallMoleculeFeature {

  /**
   * Property enumeration for SmallMoleculeFeature.
   */
  public static enum Properties {
      prefix("prefix"), 
      headerPrefix("header_prefix"), 
      smfId("smf_id"), 
      smeIdRefs("sme_id_refs"), 
      smeIdRefAmbiguityCode("sme_id_ref_ambiguity_code"), 
      adductIon("adduct_ion"), 
      isotopomer("isotopomer"), 
      expMassToCharge("exp_mass_to_charge"), 
      charge("charge"), 
      retentionTimeInSeconds("retention_time_in_seconds"), 
      retentionTimeInSecondsStart("retention_time_in_seconds_start"), 
      retentionTimeInSecondsEnd("retention_time_in_seconds_end"), 
      abundanceAssay("abundance_assay"), 
      opt("opt"), 
      comment("comment");

    private final String propertyName;

    private Properties(String propertyName) {
      this.propertyName = propertyName;
    }

    public String getPropertyName() {
      return propertyName;
    }

    public String toString() {
      return propertyName;
    }

    public String toUpper() {
      return propertyName.toUpperCase();
    }

    public static Properties of(String value) {
      if(value==null) {
        throw new NullPointerException("Argument value must not be null!");
      }
      return Arrays.asList(Properties.values()).stream().filter(m -> m.propertyName.equals(value.toLowerCase())).findAny().orElseThrow(IllegalArgumentException::new);
    }
  };
  
  /**
   * The small molecule feature table row prefix. SMF MUST be used for rows of the small molecule feature table.
   */
  public enum PrefixEnum {
    SMF(String.valueOf("SMF"));

    private String value;

    PrefixEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static PrefixEnum fromValue(String value) {
      for (PrefixEnum b : PrefixEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_PREFIX = "prefix";
  
  private PrefixEnum prefix = PrefixEnum.SMF;

  /**
   * The small molecule feature table header prefix. SFH MUST be used for the small molecule feature table header line (the column labels).
   */
  public enum HeaderPrefixEnum {
    SFH(String.valueOf("SFH"));

    private String value;

    HeaderPrefixEnum(String value) {
      this.value = value;
    }

    @JsonValue
    public String getValue() {
      return value;
    }

    @Override
    public String toString() {
      return String.valueOf(value);
    }

    @JsonCreator
    public static HeaderPrefixEnum fromValue(String value) {
      for (HeaderPrefixEnum b : HeaderPrefixEnum.values()) {
        if (b.value.equals(value)) {
          return b;
        }
      }
      throw new IllegalArgumentException("Unexpected value '" + value + "'");
    }
  }

  public static final String JSON_PROPERTY_HEADER_PREFIX = "header_prefix";
  
  private HeaderPrefixEnum headerPrefix = HeaderPrefixEnum.SFH;

  public static final String JSON_PROPERTY_SMF_ID = "smf_id";
  @jakarta.validation.constraints.NotNull
  private Integer smfId;

  public static final String JSON_PROPERTY_SME_ID_REFS = "sme_id_refs";
  
  private List<Integer> smeIdRefs = new ArrayList<>();

  public static final String JSON_PROPERTY_SME_ID_REF_AMBIGUITY_CODE = "sme_id_ref_ambiguity_code";
  
  private Integer smeIdRefAmbiguityCode;

  public static final String JSON_PROPERTY_ADDUCT_ION = "adduct_ion";
  
  private String adductIon;

  public static final String JSON_PROPERTY_ISOTOPOMER = "isotopomer";
  
  private Parameter isotopomer;

  public static final String JSON_PROPERTY_EXP_MASS_TO_CHARGE = "exp_mass_to_charge";
  @jakarta.validation.constraints.NotNull
  private Double expMassToCharge;

  public static final String JSON_PROPERTY_CHARGE = "charge";
  @jakarta.validation.constraints.NotNull
  private Integer charge;

  public static final String JSON_PROPERTY_RETENTION_TIME_IN_SECONDS = "retention_time_in_seconds";
  
  private Double retentionTimeInSeconds;

  public static final String JSON_PROPERTY_RETENTION_TIME_IN_SECONDS_START = "retention_time_in_seconds_start";
  
  private Double retentionTimeInSecondsStart;

  public static final String JSON_PROPERTY_RETENTION_TIME_IN_SECONDS_END = "retention_time_in_seconds_end";
  
  private Double retentionTimeInSecondsEnd;

  public static final String JSON_PROPERTY_ABUNDANCE_ASSAY = "abundance_assay";
  
  private List<Double> abundanceAssay = new ArrayList<>();

  public static final String JSON_PROPERTY_OPT = "opt";
  
  private List<@Valid OptColumnMapping> opt = new ArrayList<>();

  public static final String JSON_PROPERTY_COMMENT = "comment";
  
  private List<@Valid Comment> comment = new ArrayList<>();

  public SmallMoleculeFeature() { 
  }

  @JsonCreator
  public SmallMoleculeFeature(
    @JsonProperty(JSON_PROPERTY_PREFIX) PrefixEnum prefix, 
    @JsonProperty(JSON_PROPERTY_HEADER_PREFIX) HeaderPrefixEnum headerPrefix
  ) {
  this();
    this.prefix = prefix;
    this.headerPrefix = headerPrefix;
  }

  /**
   * The small molecule feature table row prefix. SMF MUST be used for rows of the small molecule feature table.
   * @return prefix
   */
  

  @JsonProperty(value = JSON_PROPERTY_PREFIX, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public PrefixEnum getPrefix() {
    return prefix;
  }




  /**
   * The small molecule feature table header prefix. SFH MUST be used for the small molecule feature table header line (the column labels).
   * @return headerPrefix
   */
  

  @JsonProperty(value = JSON_PROPERTY_HEADER_PREFIX, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public HeaderPrefixEnum getHeaderPrefix() {
    return headerPrefix;
  }




  public SmallMoleculeFeature smfId(@jakarta.validation.constraints.NotNull Integer smfId) {
    this.smfId = smfId;
    return this;
  }

  /**
   * A within file unique identifier for the small molecule feature.
   * @return smfId
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @JsonProperty(value = JSON_PROPERTY_SMF_ID, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Integer getSmfId() {
    return smfId;
  }


  @JsonProperty(value = JSON_PROPERTY_SMF_ID, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSmfId(@jakarta.validation.constraints.NotNull Integer smfId) {
    this.smfId = smfId;
  }


  public SmallMoleculeFeature smeIdRefs( List<Integer> smeIdRefs) {
    this.smeIdRefs = smeIdRefs;
    return this;
  }

  public SmallMoleculeFeature addSmeIdRefsItem(Integer smeIdRefsItem) {
    if (this.smeIdRefs == null) {
      this.smeIdRefs = new ArrayList<>();
    }
    this.smeIdRefs.add(smeIdRefsItem);
    return this;
  }

  /**
   * References to the identification evidence (SME elements) via referencing SME_ID values. Multiple values MAY be provided as a “|” separated list to indicate ambiguity in the identification or to indicate that different types of data supported the identifiction (see SME_ID_REF_ambiguity_code). For the case of a consensus approach where multiple adduct forms are used to infer the SML ID, different features should just reference the same SME_ID value(s).
   * @return smeIdRefs
   */
  

  @JsonProperty(value = JSON_PROPERTY_SME_ID_REFS, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<Integer> getSmeIdRefs() {
    return smeIdRefs;
  }


  @JsonProperty(value = JSON_PROPERTY_SME_ID_REFS, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSmeIdRefs( List<Integer> smeIdRefs) {
    this.smeIdRefs = smeIdRefs;
  }


  public SmallMoleculeFeature smeIdRefAmbiguityCode( Integer smeIdRefAmbiguityCode) {
    this.smeIdRefAmbiguityCode = smeIdRefAmbiguityCode;
    return this;
  }

  /**
   * If multiple values are given under SME_ID_REFS, one of the following codes MUST be provided. 1&#x3D;Ambiguous identification; 2&#x3D;Only different evidence streams for the same molecule with no ambiguity; 3&#x3D;Both ambiguous identification and multiple evidence streams. If there are no or one value under SME_ID_REFs, this MUST be reported as null.
   * @return smeIdRefAmbiguityCode
   */
  

  @JsonProperty(value = JSON_PROPERTY_SME_ID_REF_AMBIGUITY_CODE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Integer getSmeIdRefAmbiguityCode() {
    return smeIdRefAmbiguityCode;
  }


  @JsonProperty(value = JSON_PROPERTY_SME_ID_REF_AMBIGUITY_CODE, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setSmeIdRefAmbiguityCode( Integer smeIdRefAmbiguityCode) {
    this.smeIdRefAmbiguityCode = smeIdRefAmbiguityCode;
  }


  public SmallMoleculeFeature adductIon( String adductIon) {
    this.adductIon = adductIon;
    return this;
  }

  /**
   * The assumed classification of this molecule’s adduct ion after detection, following the general style in the 2013 IUPAC recommendations on terms relating to MS e.g. [M+H]1+, [M+Na]1+, [M+NH4]1+, [M-H]1-, [M+Cl]1-, [M+H]1+.
   * @return adductIon
   */
  
 @Pattern(regexp="^\\[\\d*M([+-][\\w\\d]+)*\\]\\d*[+-]$")
  @JsonProperty(value = JSON_PROPERTY_ADDUCT_ION, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public String getAdductIon() {
    return adductIon;
  }


  @JsonProperty(value = JSON_PROPERTY_ADDUCT_ION, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAdductIon( String adductIon) {
    this.adductIon = adductIon;
  }


  public SmallMoleculeFeature isotopomer( Parameter isotopomer) {
    this.isotopomer = isotopomer;
    return this;
  }

  /**
   * Get isotopomer
   * @return isotopomer
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_ISOTOPOMER, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Parameter getIsotopomer() {
    return isotopomer;
  }


  @JsonProperty(value = JSON_PROPERTY_ISOTOPOMER, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setIsotopomer( Parameter isotopomer) {
    this.isotopomer = isotopomer;
  }


  public SmallMoleculeFeature expMassToCharge(@jakarta.validation.constraints.NotNull Double expMassToCharge) {
    this.expMassToCharge = expMassToCharge;
    return this;
  }

  /**
   * The experimental mass/charge value for the feature, by default assumed to be the mean across assays or a representative value. For approaches that report isotopomers as SMF rows, then the m/z of the isotopomer MUST be reported here.
   * @return expMassToCharge
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @JsonProperty(value = JSON_PROPERTY_EXP_MASS_TO_CHARGE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Double getExpMassToCharge() {
    return expMassToCharge;
  }


  @JsonProperty(value = JSON_PROPERTY_EXP_MASS_TO_CHARGE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setExpMassToCharge(@jakarta.validation.constraints.NotNull Double expMassToCharge) {
    this.expMassToCharge = expMassToCharge;
  }


  public SmallMoleculeFeature charge(@jakarta.validation.constraints.NotNull Integer charge) {
    this.charge = charge;
    return this;
  }

  /**
   * The feature’s charge value using positive integers both for positive and negative polarity modes.
   * @return charge
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @JsonProperty(value = JSON_PROPERTY_CHARGE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Integer getCharge() {
    return charge;
  }


  @JsonProperty(value = JSON_PROPERTY_CHARGE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setCharge(@jakarta.validation.constraints.NotNull Integer charge) {
    this.charge = charge;
  }


  public SmallMoleculeFeature retentionTimeInSeconds( Double retentionTimeInSeconds) {
    this.retentionTimeInSeconds = retentionTimeInSeconds;
    return this;
  }

  /**
   * The apex of the feature on the retention time axis, in a Master or aggregate MS run. Retention time MUST be reported in seconds. Retention time values for individual MS runs (i.e. before alignment) MAY be reported as optional columns. Retention time SHOULD only be null in the case of direct infusion MS or other techniques where a retention time value is absent or unknown. Relative retention time or retention time index values MAY be reported as optional columns, and could be considered for inclusion in future versions of mzTab as appropriate.
   * @return retentionTimeInSeconds
   */
  

  @JsonProperty(value = JSON_PROPERTY_RETENTION_TIME_IN_SECONDS, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Double getRetentionTimeInSeconds() {
    return retentionTimeInSeconds;
  }


  @JsonProperty(value = JSON_PROPERTY_RETENTION_TIME_IN_SECONDS, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRetentionTimeInSeconds( Double retentionTimeInSeconds) {
    this.retentionTimeInSeconds = retentionTimeInSeconds;
  }


  public SmallMoleculeFeature retentionTimeInSecondsStart( Double retentionTimeInSecondsStart) {
    this.retentionTimeInSecondsStart = retentionTimeInSecondsStart;
    return this;
  }

  /**
   * The start time of the feature on the retention time axis, in a Master or aggregate MS run. Retention time MUST be reported in seconds. Retention time start and end SHOULD only be null in the case of direct infusion MS or other techniques where a retention time value is absent or unknown and MAY be reported in optional columns.
   * @return retentionTimeInSecondsStart
   */
  

  @JsonProperty(value = JSON_PROPERTY_RETENTION_TIME_IN_SECONDS_START, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Double getRetentionTimeInSecondsStart() {
    return retentionTimeInSecondsStart;
  }


  @JsonProperty(value = JSON_PROPERTY_RETENTION_TIME_IN_SECONDS_START, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRetentionTimeInSecondsStart( Double retentionTimeInSecondsStart) {
    this.retentionTimeInSecondsStart = retentionTimeInSecondsStart;
  }


  public SmallMoleculeFeature retentionTimeInSecondsEnd( Double retentionTimeInSecondsEnd) {
    this.retentionTimeInSecondsEnd = retentionTimeInSecondsEnd;
    return this;
  }

  /**
   * The end time of the feature on the retention time axis, in a Master or aggregate MS run. Retention time MUST be reported in seconds. Retention time start and end SHOULD only be null in the case of direct infusion MS or other techniques where a retention time value is absent or unknown and MAY be reported in optional columns..
   * @return retentionTimeInSecondsEnd
   */
  

  @JsonProperty(value = JSON_PROPERTY_RETENTION_TIME_IN_SECONDS_END, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public Double getRetentionTimeInSecondsEnd() {
    return retentionTimeInSecondsEnd;
  }


  @JsonProperty(value = JSON_PROPERTY_RETENTION_TIME_IN_SECONDS_END, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setRetentionTimeInSecondsEnd( Double retentionTimeInSecondsEnd) {
    this.retentionTimeInSecondsEnd = retentionTimeInSecondsEnd;
  }


  public SmallMoleculeFeature abundanceAssay( List<Double> abundanceAssay) {
    this.abundanceAssay = abundanceAssay;
    return this;
  }

  public SmallMoleculeFeature addAbundanceAssayItem(Double abundanceAssayItem) {
    if (this.abundanceAssay == null) {
      this.abundanceAssay = new ArrayList<>();
    }
    this.abundanceAssay.add(abundanceAssayItem);
    return this;
  }

  /**
   * The feature’s abundance in every assay described in the metadata section MUST be reported. Null or zero values may be reported as appropriate.
   * @return abundanceAssay
   */
  

  @JsonProperty(value = JSON_PROPERTY_ABUNDANCE_ASSAY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<Double> getAbundanceAssay() {
    return abundanceAssay;
  }


  @JsonProperty(value = JSON_PROPERTY_ABUNDANCE_ASSAY, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setAbundanceAssay( List<Double> abundanceAssay) {
    this.abundanceAssay = abundanceAssay;
  }


  public SmallMoleculeFeature opt( List<@Valid OptColumnMapping> opt) {
    this.opt = opt;
    return this;
  }

  public SmallMoleculeFeature addOptItem(OptColumnMapping optItem) {
    if (this.opt == null) {
      this.opt = new ArrayList<>();
    }
    this.opt.add(optItem);
    return this;
  }

  /**
   * Additional columns can be added to the end of the small molecule feature table. These column headers MUST start with the prefix “opt_” followed by the {identifier} of the object they reference: assay, study variable, MS run or “global” (if the value relates to all replicates). Column names MUST only contain the following characters: ‘A’-‘Z’, ‘a’-‘z’, ‘0’-‘9’, ‘’, ‘-’, ‘[’, ‘]’, and ‘:’. CV parameter accessions MAY be used for optional columns following the format: opt{identifier}_cv_{accession}_\\{parameter name}. Spaces within the parameter’s name MUST be replaced by ‘_’. 
   * @return opt
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_OPT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid OptColumnMapping> getOpt() {
    return opt;
  }


  @JsonProperty(value = JSON_PROPERTY_OPT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setOpt( List<@Valid OptColumnMapping> opt) {
    this.opt = opt;
  }


  public SmallMoleculeFeature comment( List<@Valid Comment> comment) {
    this.comment = comment;
    return this;
  }

  public SmallMoleculeFeature addCommentItem(Comment commentItem) {
    if (this.comment == null) {
      this.comment = new ArrayList<>();
    }
    this.comment.add(commentItem);
    return this;
  }

  /**
   * Get comment
   * @return comment
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_COMMENT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid Comment> getComment() {
    return comment;
  }


  @JsonProperty(value = JSON_PROPERTY_COMMENT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setComment( List<@Valid Comment> comment) {
    this.comment = comment;
  }


  /**
   * Return true if this SmallMoleculeFeature object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SmallMoleculeFeature smallMoleculeFeature = (SmallMoleculeFeature) o;
    return Objects.equals(this.prefix, smallMoleculeFeature.prefix) &&
        Objects.equals(this.headerPrefix, smallMoleculeFeature.headerPrefix) &&
        Objects.equals(this.smfId, smallMoleculeFeature.smfId) &&
        Objects.equals(this.smeIdRefs, smallMoleculeFeature.smeIdRefs) &&
        Objects.equals(this.smeIdRefAmbiguityCode, smallMoleculeFeature.smeIdRefAmbiguityCode) &&
        Objects.equals(this.adductIon, smallMoleculeFeature.adductIon) &&
        Objects.equals(this.isotopomer, smallMoleculeFeature.isotopomer) &&
        Objects.equals(this.expMassToCharge, smallMoleculeFeature.expMassToCharge) &&
        Objects.equals(this.charge, smallMoleculeFeature.charge) &&
        Objects.equals(this.retentionTimeInSeconds, smallMoleculeFeature.retentionTimeInSeconds) &&
        Objects.equals(this.retentionTimeInSecondsStart, smallMoleculeFeature.retentionTimeInSecondsStart) &&
        Objects.equals(this.retentionTimeInSecondsEnd, smallMoleculeFeature.retentionTimeInSecondsEnd) &&
        Objects.equals(this.abundanceAssay, smallMoleculeFeature.abundanceAssay) &&
        Objects.equals(this.opt, smallMoleculeFeature.opt) &&
        Objects.equals(this.comment, smallMoleculeFeature.comment);
  }

  @Override
  public int hashCode() {
    return Objects.hash(prefix, headerPrefix, smfId, smeIdRefs, smeIdRefAmbiguityCode, adductIon, isotopomer, expMassToCharge, charge, retentionTimeInSeconds, retentionTimeInSecondsStart, retentionTimeInSecondsEnd, abundanceAssay, opt, comment);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SmallMoleculeFeature {\n");
    sb.append("    prefix: ").append(toIndentedString(prefix)).append("\n");
    sb.append("    headerPrefix: ").append(toIndentedString(headerPrefix)).append("\n");
    sb.append("    smfId: ").append(toIndentedString(smfId)).append("\n");
    sb.append("    smeIdRefs: ").append(toIndentedString(smeIdRefs)).append("\n");
    sb.append("    smeIdRefAmbiguityCode: ").append(toIndentedString(smeIdRefAmbiguityCode)).append("\n");
    sb.append("    adductIon: ").append(toIndentedString(adductIon)).append("\n");
    sb.append("    isotopomer: ").append(toIndentedString(isotopomer)).append("\n");
    sb.append("    expMassToCharge: ").append(toIndentedString(expMassToCharge)).append("\n");
    sb.append("    charge: ").append(toIndentedString(charge)).append("\n");
    sb.append("    retentionTimeInSeconds: ").append(toIndentedString(retentionTimeInSeconds)).append("\n");
    sb.append("    retentionTimeInSecondsStart: ").append(toIndentedString(retentionTimeInSecondsStart)).append("\n");
    sb.append("    retentionTimeInSecondsEnd: ").append(toIndentedString(retentionTimeInSecondsEnd)).append("\n");
    sb.append("    abundanceAssay: ").append(toIndentedString(abundanceAssay)).append("\n");
    sb.append("    opt: ").append(toIndentedString(opt)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

