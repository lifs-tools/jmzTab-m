/*
 * mzTab-M reference implementation and validation API.
 * This is the mzTab-M reference implementation and validation API service.
 *
 * The version of the OpenAPI document: 2.0.0
 * Contact: nils.hoffmann@cebitec.uni-bielefeld.de
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package org.lifstools.mztab2.model;

import java.net.URLEncoder;
import java.nio.charset.StandardCharsets;
import java.util.StringJoiner;
import java.util.Objects;
import java.util.Map;
import java.util.HashMap;
import java.util.Locale;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonCreator;
import com.fasterxml.jackson.annotation.JsonTypeName;
import com.fasterxml.jackson.annotation.JsonValue;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import org.lifstools.mztab2.model.Comment;
import org.lifstools.mztab2.model.Metadata;
import org.lifstools.mztab2.model.SmallMoleculeEvidence;
import org.lifstools.mztab2.model.SmallMoleculeFeature;
import org.lifstools.mztab2.model.SmallMoleculeSummary;
import com.fasterxml.jackson.annotation.JsonPropertyOrder;
import jakarta.validation.constraints.*;
import jakarta.validation.Valid;
import org.hibernate.validator.constraints.*;

/**
 * mzTab-M is intended as a reporting standard for quantitative results from metabolomics/lipodomics approaches.  This format is further intended to provide local LIMS systems as well as MS metabolomics repositories a simple way to share and combine basic information.  The mzTab-M format consists of four cross-referenced data tables:          * Metadata (MTD),      * Small Molecule (SML),      * Small Molecule Feature (SMF) and the      * Small Molecule Evidence (SME).   The MTD and SML tables are mandatory, and for a file to contain any evidence about how molecules were quantified or identified by software, then all four tables must be present. The tables must follow the order MTD, SML, SMF and SME, with a blank line separating each table.   The structure of each table, in terms of the rows and columns that must be present is tightly specified and formally defined and explained in the mzTab-M specification document. mzTab-M files MUST have one Metadata (MTD) section and one Small Molecule (SML) Section. In practice, we expect that most files SHOULD also include one Small Molecule Feature (SMF) section, and one Small Molecule Evidence (SME) Section.  Files lacking SMF and SME sections can only present summary data about quantified molecules, without any evidence trail for how those values were derived. It will be left to reading software to determine whether additional validation will be requested such that SMF and SME tables MUST be present. 
 */
@JsonPropertyOrder({
  MzTab.JSON_PROPERTY_METADATA,
  MzTab.JSON_PROPERTY_SMALL_MOLECULE_SUMMARY,
  MzTab.JSON_PROPERTY_SMALL_MOLECULE_FEATURE,
  MzTab.JSON_PROPERTY_SMALL_MOLECULE_EVIDENCE,
  MzTab.JSON_PROPERTY_COMMENT
})
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", date = "2025-11-08T17:12:00.460651+01:00[Europe/Berlin]", comments = "Generator version: 7.17.0")
public class MzTab {

  /**
   * Property enumeration for MzTab.
   */
  public static enum Properties {
      metadata("metadata"), 
      smallMoleculeSummary("smallMoleculeSummary"), 
      smallMoleculeFeature("smallMoleculeFeature"), 
      smallMoleculeEvidence("smallMoleculeEvidence"), 
      comment("comment");

    private final String propertyName;

    private Properties(String propertyName) {
      this.propertyName = propertyName;
    }

    public String getPropertyName() {
      return propertyName;
    }

    public String toString() {
      return propertyName;
    }

    public String toUpper() {
      return propertyName.toUpperCase();
    }

    public static Properties of(String value) {
      if(value==null) {
        throw new NullPointerException("Argument value must not be null!");
      }
      return Arrays.asList(Properties.values()).stream().filter(m -> m.propertyName.equals(value.toLowerCase())).findAny().orElseThrow(IllegalArgumentException::new);
    }
  };
  
  public static final String JSON_PROPERTY_METADATA = "metadata";
  @jakarta.validation.constraints.NotNull
  private Metadata metadata;

  public static final String JSON_PROPERTY_SMALL_MOLECULE_SUMMARY = "smallMoleculeSummary";
  @jakarta.validation.constraints.NotNull
  private List<@Valid SmallMoleculeSummary> smallMoleculeSummary = new ArrayList<>();

  public static final String JSON_PROPERTY_SMALL_MOLECULE_FEATURE = "smallMoleculeFeature";
  @jakarta.validation.constraints.NotNull
  private List<@Valid SmallMoleculeFeature> smallMoleculeFeature = new ArrayList<>();

  public static final String JSON_PROPERTY_SMALL_MOLECULE_EVIDENCE = "smallMoleculeEvidence";
  @jakarta.validation.constraints.NotNull
  private List<@Valid SmallMoleculeEvidence> smallMoleculeEvidence = new ArrayList<>();

  public static final String JSON_PROPERTY_COMMENT = "comment";
  
  private List<@Valid Comment> comment = new ArrayList<>();

  public MzTab() { 
  }

  public MzTab metadata(@jakarta.validation.constraints.NotNull Metadata metadata) {
    this.metadata = metadata;
    return this;
  }

  /**
   * Get metadata
   * @return metadata
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_METADATA, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public Metadata getMetadata() {
    return metadata;
  }


  @JsonProperty(value = JSON_PROPERTY_METADATA, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setMetadata(@jakarta.validation.constraints.NotNull Metadata metadata) {
    this.metadata = metadata;
  }


  public MzTab smallMoleculeSummary(@jakarta.validation.constraints.NotNull List<@Valid SmallMoleculeSummary> smallMoleculeSummary) {
    this.smallMoleculeSummary = smallMoleculeSummary;
    return this;
  }

  public MzTab addSmallMoleculeSummaryItem(SmallMoleculeSummary smallMoleculeSummaryItem) {
    if (this.smallMoleculeSummary == null) {
      this.smallMoleculeSummary = new ArrayList<>();
    }
    this.smallMoleculeSummary.add(smallMoleculeSummaryItem);
    return this;
  }

  /**
   * The small molecule section is table-based. The small molecule section MUST always come after the metadata section. All table columns MUST be Tab separated. There MUST NOT be any empty cells; missing values MUST be reported using “null” for columns where Is Nullable &#x3D; “True”.  Each row of the small molecule section is intended to report one final result to be communicated in terms of a molecule that has been quantified. In many cases, this may be the molecule of biological interest, although in some cases, the final result could be a derivatized form as appropriate – although it is desirable for the database identifier(s) to reference to the biological (non-derivatized) form. In general, different adduct forms would generally be reported in the Small Molecule Feature section.  The order of columns MUST follow the order specified below.  All columns are MANDATORY except for “opt_” columns. 
   * @return smallMoleculeSummary
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @Size(min=1)
  @JsonProperty(value = JSON_PROPERTY_SMALL_MOLECULE_SUMMARY, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<@Valid SmallMoleculeSummary> getSmallMoleculeSummary() {
    return smallMoleculeSummary;
  }


  @JsonProperty(value = JSON_PROPERTY_SMALL_MOLECULE_SUMMARY, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSmallMoleculeSummary(@jakarta.validation.constraints.NotNull List<@Valid SmallMoleculeSummary> smallMoleculeSummary) {
    this.smallMoleculeSummary = smallMoleculeSummary;
  }


  public MzTab smallMoleculeFeature(@jakarta.validation.constraints.NotNull List<@Valid SmallMoleculeFeature> smallMoleculeFeature) {
    this.smallMoleculeFeature = smallMoleculeFeature;
    return this;
  }

  public MzTab addSmallMoleculeFeatureItem(SmallMoleculeFeature smallMoleculeFeatureItem) {
    if (this.smallMoleculeFeature == null) {
      this.smallMoleculeFeature = new ArrayList<>();
    }
    this.smallMoleculeFeature.add(smallMoleculeFeatureItem);
    return this;
  }

  /**
   * The small molecule feature section is table-based, representing individual MS regions (generally considered to be the elution profile for all isotopomers formed from a single charge state of a molecule), that have been measured/quantified. However, for approaches that quantify individual isotopomers e.g. stable isotope labelling/flux studies, then each SMF row SHOULD represent a single isotopomer.  Different adducts or derivatives and different charge states of individual molecules should be reported as separate SMF rows.  The small molecule feature section MUST always come after the Small Molecule Table. All table columns MUST be Tab separated. There MUST NOT be any empty cells. Missing values MUST be reported using “null”.  The order of columns MUST follow the order specified below.  All columns are MANDATORY except for “opt_” columns. 
   * @return smallMoleculeFeature
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_SMALL_MOLECULE_FEATURE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<@Valid SmallMoleculeFeature> getSmallMoleculeFeature() {
    return smallMoleculeFeature;
  }


  @JsonProperty(value = JSON_PROPERTY_SMALL_MOLECULE_FEATURE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSmallMoleculeFeature(@jakarta.validation.constraints.NotNull List<@Valid SmallMoleculeFeature> smallMoleculeFeature) {
    this.smallMoleculeFeature = smallMoleculeFeature;
  }


  public MzTab smallMoleculeEvidence(@jakarta.validation.constraints.NotNull List<@Valid SmallMoleculeEvidence> smallMoleculeEvidence) {
    this.smallMoleculeEvidence = smallMoleculeEvidence;
    return this;
  }

  public MzTab addSmallMoleculeEvidenceItem(SmallMoleculeEvidence smallMoleculeEvidenceItem) {
    if (this.smallMoleculeEvidence == null) {
      this.smallMoleculeEvidence = new ArrayList<>();
    }
    this.smallMoleculeEvidence.add(smallMoleculeEvidenceItem);
    return this;
  }

  /**
   * The small molecule evidence section is table-based, representing evidence for identifications of small molecules/features, from database search or any other process used to give putative identifications to molecules. In a typical case, each row represents one result from a single search or intepretation of a piece of evidence e.g. a database search with a fragmentation spectrum. Multiple results from a given input data item (e.g. one fragment spectrum) SHOULD share the same value under evidence_input_id.  The small molecule evidence section MUST always come after the Small Molecule Feature Table. All table columns MUST be Tab separated. There MUST NOT be any empty cells. Missing values MUST be reported using “null”.  The order of columns MUST follow the order specified below.  All columns are MANDATORY except for “opt_” columns. 
   * @return smallMoleculeEvidence
   */
  @jakarta.validation.constraints.NotNull
  @NotNull
  @Valid
  @JsonProperty(value = JSON_PROPERTY_SMALL_MOLECULE_EVIDENCE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public List<@Valid SmallMoleculeEvidence> getSmallMoleculeEvidence() {
    return smallMoleculeEvidence;
  }


  @JsonProperty(value = JSON_PROPERTY_SMALL_MOLECULE_EVIDENCE, required = true)
  @JsonInclude(value = JsonInclude.Include.ALWAYS)
  public void setSmallMoleculeEvidence(@jakarta.validation.constraints.NotNull List<@Valid SmallMoleculeEvidence> smallMoleculeEvidence) {
    this.smallMoleculeEvidence = smallMoleculeEvidence;
  }


  public MzTab comment( List<@Valid Comment> comment) {
    this.comment = comment;
    return this;
  }

  public MzTab addCommentItem(Comment commentItem) {
    if (this.comment == null) {
      this.comment = new ArrayList<>();
    }
    this.comment.add(commentItem);
    return this;
  }

  /**
   * Comment lines can be placed anywhere in an mzTab file. These lines must start with the three-letter code COM and are ignored by most parsers. Empty lines can also occur anywhere in an mzTab file and are ignored. 
   * @return comment
   */
  
  @Valid
  @JsonProperty(value = JSON_PROPERTY_COMMENT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public List<@Valid Comment> getComment() {
    return comment;
  }


  @JsonProperty(value = JSON_PROPERTY_COMMENT, required = false)
  @JsonInclude(value = JsonInclude.Include.USE_DEFAULTS)
  public void setComment( List<@Valid Comment> comment) {
    this.comment = comment;
  }


  /**
   * Return true if this MzTab object is equal to o.
   */
  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    MzTab mzTab = (MzTab) o;
    return Objects.equals(this.metadata, mzTab.metadata) &&
        Objects.equals(this.smallMoleculeSummary, mzTab.smallMoleculeSummary) &&
        Objects.equals(this.smallMoleculeFeature, mzTab.smallMoleculeFeature) &&
        Objects.equals(this.smallMoleculeEvidence, mzTab.smallMoleculeEvidence) &&
        Objects.equals(this.comment, mzTab.comment);
  }

  @Override
  public int hashCode() {
    return Objects.hash(metadata, smallMoleculeSummary, smallMoleculeFeature, smallMoleculeEvidence, comment);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class MzTab {\n");
    sb.append("    metadata: ").append(toIndentedString(metadata)).append("\n");
    sb.append("    smallMoleculeSummary: ").append(toIndentedString(smallMoleculeSummary)).append("\n");
    sb.append("    smallMoleculeFeature: ").append(toIndentedString(smallMoleculeFeature)).append("\n");
    sb.append("    smallMoleculeEvidence: ").append(toIndentedString(smallMoleculeEvidence)).append("\n");
    sb.append("    comment: ").append(toIndentedString(comment)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}

